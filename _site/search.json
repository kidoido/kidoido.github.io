[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Projekty/MLR/index.html",
    "href": "Projekty/MLR/index.html",
    "title": "Function Factory",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\n\nOpis projektu\nZadanie polega na napisaniu funkcji createFitter(), która przyjmuje tylko jeden argument size. Zadaniem funkcji jest stworzenie nowej funkcji, tzw. fittera, która zawiera prostą sięć neuronową MLP o jednej warstwie ukrytej o wielkości size. Funkcja ta powinna przyjmować dwa argumenty: data, który jest ramką danych (alternatywnie obiektem dziedziczącym z data.frame, np. tbl_df) oraz formula, który jest formuła opisującą co w podanej ramce danych jest targetem a co features. Przykładowo, jeżeli w ramace danych mamy zmienne (kolumny) x i y to formuła y ~ x oznacza, że sieć na podstawie zmiennej x prognozuje zmienną y. Oczywiście powinny być wspierane skróty, np. y ~ . oznacza, że zmienna y jest prognozowana na podstawie wszystkich pozostałych w ramce danych zmiennych. Zadaniem fittera jest zdefiniowane nowej kolejnej funkcji, która jest predyktorem a więc funkcją, która dla podanych zmiennych zwraca predykcje. Tak więc fitter na podstawie podanej próby trenuje sieć neuronową i zwraca funkcję, predyktor, która zawiera wytrenowaną sieć neuronową i jej zadaniem jest tworzenie predykcji z wykorzystaniem wytrenowanej sieci neuronowej.\n\n\nMoje rozwiązanie\n\nlibrary(dplyr)\n\ncreateFitter &lt;- function(size) {\n  #jesli nie mam pakietu, to go instaluje, jesli mam to włączam\n  if(!require(nnet)){\n    install.packages(\"nnet\")\n    library(nnet)\n  } else {\n    library(nnet)\n  }\n  \n  return(function(data, formula){ \n    # fitter\n    nn &lt;- nnet(formula, data, size = c(size), maxit=1000, rang = 0.1, decay = 5e-4, linout=T)\n    ## definicja f. lines dla klasy data.frame\n    e &lt;- parent.env(environment())\n    e$lines &lt;- function(x, ...) {\n      graphics::lines(x = x[,1], y = x[,2], ...)\n    }\n    \n    return(function(newData){\n      #predyktor\n      #Zwraca df ktory ma dwie kolumny, x z zbioru dTest i y wyliczone na podstawie sieci i nowych x\n      out &lt;- data.frame(newData[,1], predict(nn, newData))\n      return(out)\n    })\n  })\n}\n\n\n\nPrzykłady\n\nPrzykład 1\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzenie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 10)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 1\n\n\n\n\n\n\nPrzykład 2\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 3)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 2\n\n\n\n\n\n\nPrzyklad 3\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd1 &lt;- tibble(\n  x = rnorm(10^3, mean = -5),\n  y = (x + 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd2 &lt;- tibble(\n  x = rnorm(10^3, mean = 5),\n  y = (x - 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd &lt;- rbind(d1, d2)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter3 &lt;- createFitter(size = 3)\nfitter20 &lt;- createFitter(size = 20)\n\n### Tworzenie predyktora. \npredictor3 &lt;- fitter3(formula = y ~ x, data = d)\npredictor20 &lt;- fitter20(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n#| label: przyklad-3\n#| fig-cap: \"Przykład 3\"\n#| warning: false\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\nlines(x = predictor3(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\nlines(x = predictor20(newData = dTest),\n      col = rgb(0, .5, 1, .9),\n      lwd = 2)"
  },
  {
    "objectID": "Projekty/GA/index.html",
    "href": "Projekty/GA/index.html",
    "title": "Algorytm genetyczny",
    "section": "",
    "text": "Projekt wykonany w Pythonie na zajęcia Credit Scoring.\nPodstawowym zagadnieniem było zbudowanie modelu do oceny ryzyka potencjalnych klientów kredytowych za pomocą kodów udostępnionych przez wykłądowcę, pana dr Karola Przanowskiego. Dla chętnych była możliowość ich udoskonalenia wg własnej inwencji twórczej. Ja zdecydowałem się zaimplementować algorytm genetyczny do wyboru zmiennyc modelu.\nW danych mieliśmy ok. 200 zmiennych, a do modelu szukaliśmy najlepszej kombinacji kilku/kilkunastu. Głównym celem było znalezienie modelu z jak największym indeksem Gini, mierzącym jego siłę predykcyjną."
  },
  {
    "objectID": "Projekty/R6Class/index.html",
    "href": "Projekty/R6Class/index.html",
    "title": "R6Class",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\nOpis projektu\nProjekt dotyczy rozszerzonej reprezentacji szeregu czasowego. W języku R jest wiele możliwości reprezentowania szeregów czasowych. Podstawowe klasy to ts i mts. Klasy, które rozszerzają te klasy to zoo i xts. Wszystkie te klasy reprezentują jedynie dane a więc dane dotyczące czasu i wartości. W tym projekcie chcemy do danych dołożyć operacje, które są wykonywane na szeregach czasowych oraz metody, które tworzą prognozy.\nTechnicznie, zadaniem w projekcie jest zdefiniowanie klasy timeSeries w modelu obiektowym R6, która na podstawie wektora określającego czas i wektora wartości, inicjalizuje instancję klasy. Metoda new powinna przyjmować dwa argumenty: times, który przyjmuje wektor czasów (i tutaj możemy wykorzystać dowolną klasę reprezentującą datę i czas, np. Date czy yearmon) oraz values, który przyjmuje wektor wartości.\nKlasa musi oferować następujące podstawowe metody.\n\nMetoda getTimes, która zwraca podany wektor czasów.\nMetoda getValues, która zwraca podany wektor wartości.\nMetoda getTimeSeries, która zwraca szereg czasowy. W rozwiązaniu proszę wykorzystać klasę xts.\n\nProjekt jest zatem rozszerzeniem klasy xts.\nPowyższe metody są typowymi fundamentalnymi metodami związanymi z szeregiem czasowym.\n\n\nMoja definicja funkcji\n\nlibrary(R6)\nlibrary(xts)\nlibrary(zoo)\nlibrary(tibble)\nlibrary(ggplot2)\n\ntimeSeries &lt;- R6Class(\n  classname = \"timeSeries\",\n  public = list(\n    times = NA,\n    values = NA,\n    table = NULL,\n    operations = list(),\n    models = list(),\n    paths = list(),\n    initialize = function(times, values) {\n      self$times &lt;- times\n      self$values &lt;- values\n      self$table &lt;- xts::xts(x = self$values, order.by = self$times)\n    },\n    \n    getTimes = function() {\n      self$times\n    },\n    \n    getValues = function() {\n      self$values\n    },\n    \n    getTimeSeries = function() {\n      self$table\n    },\n    \n    opsAppend = function(...) {\n      ops &lt;- list(...)\n      for (name in names(ops)) {\n        self$operations[[name]] &lt;- ops[[name]]\n      }\n    },\n    \n    opsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$operations[[key]] &lt;- NULL\n      }\n    },\n    \n    opsList = function() {\n      data.frame(id = seq_along(self$operations), name = names(self$operations))\n    },\n    modelsAppend = function(...){\n      model &lt;- list(...)\n      for (name in names(model)) {\n        self$models[[name]] &lt;- model[[name]]\n      }\n    },\n    modelsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$models[[key]] &lt;- NULL\n      }\n    },\n    modelsList = function() {\n      data.frame(id = seq_along(self$models), name = names(self$models))\n    },\n    pathsAppend = function(pathName, operations, model){\n      self$paths[[pathName]] &lt;- list(operations = operations, model = model)\n      },\n    pathsRemove = function(...) {\n      pathNames &lt;- list(...)\n      for (pathName in pathNames) {\n        self$paths[[pathName]] &lt;- NULL\n      }\n    },\n    pathsList = function() {\n      paths_df &lt;- do.call(rbind, lapply(names(self$paths), function(name) {\n        data.frame(\n          id = which(names(self$paths) == name),\n          name = name,\n          operations = paste(self$paths[[name]]$operations, collapse = \" → \"),\n          model = self$paths[[name]]$model,\n          stringsAsFactors = FALSE\n        )\n      }))\n      paths_df\n    },\n    pathsRun = function(pathName) {\n      if (!(pathName %in% names(self$paths))) {\n        stop(\"Path not found.\")\n      }\n      path &lt;- self$paths[[pathName]]\n      result &lt;- self$table\n      for (op in path$operations) {\n        result &lt;- self$operations[[op]](result)\n      }\n      prediction &lt;- self$models[[path$model]](result)\n      prediction\n    }\n    \n  )\n)\n\n\n\nPrzykłady\n\nPrzykład 1\nPoniższy przykład tworzy bardzo prosty szereg czasowy i pokazuje działanie opisanych powyżej metod.\nPrzykład pokazuje inicjalizację obiektu klasy timeSeries oraz wykorzytanie podstawowych metod. Na tej podstawie tworzony jest prosty wykres szeregu czasowego.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Pobranie wartości\ny$getValues()\n\n [1]  0.6098458  0.4099435 -0.7810027 -1.8361827 -1.5449285  0.4772184\n [7]  1.7977427  3.2979127  3.0727485  3.4848064  4.3178537  4.2509107\n[13]  4.6703100  4.7121472  4.7794286  4.5809954  5.5647332  5.2170464\n[19]  6.4517544  7.8654043  5.8598814  6.5067633  7.4208781  9.4280379\n[25]  9.0923367  8.3671124  8.7296329 10.4112159  9.0606803 11.7031760\n[31] 11.3781536 12.4338905 11.8542651 13.1636994 13.2704616 14.2704352\n[37] 14.0624996 13.6433462 12.3000801 14.5924500 14.5171203 15.7747150\n[43] 15.9910331 15.2252821 13.4741547 14.2613731 12.9586372 12.5509135\n[49] 12.3232827 12.2555017 14.9059542 14.8162603 15.5700137 15.7422401\n[55] 14.4624481 15.9140318 17.9059252 17.4145883 18.3386815 19.0920516\n\n### Pobranie wektora czasów\ny$getTimes()\n\n [1] \"Jan 2009\" \"Feb 2009\" \"Mar 2009\" \"Apr 2009\" \"May 2009\" \"Jun 2009\"\n [7] \"Jul 2009\" \"Aug 2009\" \"Sep 2009\" \"Oct 2009\" \"Nov 2009\" \"Dec 2009\"\n[13] \"Jan 2010\" \"Feb 2010\" \"Mar 2010\" \"Apr 2010\" \"May 2010\" \"Jun 2010\"\n[19] \"Jul 2010\" \"Aug 2010\" \"Sep 2010\" \"Oct 2010\" \"Nov 2010\" \"Dec 2010\"\n[25] \"Jan 2011\" \"Feb 2011\" \"Mar 2011\" \"Apr 2011\" \"May 2011\" \"Jun 2011\"\n[31] \"Jul 2011\" \"Aug 2011\" \"Sep 2011\" \"Oct 2011\" \"Nov 2011\" \"Dec 2011\"\n[37] \"Jan 2012\" \"Feb 2012\" \"Mar 2012\" \"Apr 2012\" \"May 2012\" \"Jun 2012\"\n[43] \"Jul 2012\" \"Aug 2012\" \"Sep 2012\" \"Oct 2012\" \"Nov 2012\" \"Dec 2012\"\n[49] \"Jan 2013\" \"Feb 2013\" \"Mar 2013\" \"Apr 2013\" \"May 2013\" \"Jun 2013\"\n[55] \"Jul 2013\" \"Aug 2013\" \"Sep 2013\" \"Oct 2013\" \"Nov 2013\" \"Dec 2013\"\n\n### Pobranie szeregu czasowgo (klasa xts)\nhead(y$getTimeSeries(),10)\n\n               [,1]\nJan 2009  0.6098458\nFeb 2009  0.4099435\nMar 2009 -0.7810027\nApr 2009 -1.8361827\nMay 2009 -1.5449285\nJun 2009  0.4772184\nJul 2009  1.7977427\nAug 2009  3.2979127\nSep 2009  3.0727485\nOct 2009  3.4848064\n\n### Stworzenie przykładowego wykresu\nggplot(\n  data = tibble(time = y$getTimes(), value = y$getValues()),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Example of a time series\") +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nPrzykład 2\nPodstawowe metody, opisane powyżej, nie wyczerpują operacji, które chcemy dodać do szeregu czasowego. Oczywiście katalog potencjalnych operacji nie jest skończony więc nie możemy dodać metod reprezentujących wszystkie potencjalne operacje. Z tego powodu chcemy mieć możliwość dodawania dowolnych operacji i następnie wiązania tych operacji. W pierwszej kolejności chcemy zbudować prosty system zarządzania operacjami. Na potrzeby tego projektu, operacja na szeregu czasowym, to dowolna funkcja, która jako argument przyjmuje szereg czasowy (klasa xts) i zwraca szereg czasowy (ponownie klasa xts). Tak więc musimy mieć następujące metody.\n\nMetoda opsAppend do dodawania operacji. Składania tej metody powinna być identyczna ze składnią funkcji list. Konieczne jest podanie kluczy jednoznacznie identyfikujących\nMetoda opsRemove do usuwania operacji. Metoda przyjmuje dowolną liczbę stringów, które są kluczami usuwanych operacji.\nMetoda opsList, która listuje operacje, które aktualnie są w liście dodanych operacji.\n\nPoniższy przykład pokazuje metody dodawania, listowania i usuwania operacji.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy operacje.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\n### Usuwanie operacji\ny$opsRemove(\"logs_abs\")\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2      na_omit\n\n\n\n\nPrzykład 3\nKolejnym elementem, które musi się znaleźć w klasie jest model predykcji. Na potrzeby tego projektu, przez model predkcji będziemy rozumieli dowolną funkcję, która jako argument przyjmuje obiekt klasy xts i zwraca obiekt tej klasy. Ponownie, katalog możliwych modeli predykcji nie jest zamknięty, więc również musimy mieć prosty system zarządzania. W szczególności klasa musi oferować następujące metody.\n\nMetoda modelsAppend, która pozwala na dodawanie modeli. Składnia tej metody powinna być taka jak funkcji list. Podobnie jak poporzednio, konieczne jest podanie unikalnych kluczy indetyfikujących modele.\nMetoda modelsRemove, która pozwana na usunięcie modeli. Metoda musi przyjmować stringi, które definiują dodane modele.\nMetoda modelsList, która listuje dodane modele.\n\nPoniższy przykład pokazuje zastosowanie opisanych metod.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy modele.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie prostego modelu liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identyczności\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listowanie modelu\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Usuwanie modelu\ny$modelsRemove(\"identity_prediction\")\n\n### Listowanie modelu\ny$modelsList()\n\n  id              name\n1  1 linear_prediciton\n\n\n\n\nPrzykład 4\nSame operacje oraz modele nic nie robią. Kolejne zadanie to wiązanie operatorów i kończenie ich modelami predykcji. Powiązanie takie ma postać szereg czasowy → operator 1 → operator 2 → … → operator n → model. Każde takie powiązanie nazywamy dalej ścieżką obliczeniową (path). Klasa musi mieć narzędzia do tworzenia i zarządzania takimi ścieżkami obliczeniowymi. Klasa musi oferować następujące metody.\n\nMetoda pathsAppend musi pozwalać dodawać ścieżki obliczeniowe. Metoda ta powinna przyjmować trzy argumenty. Argument pathName, który jest stringiem i jest unikalny. Argument operations, który jest wektorem stringów definiujących dodane operacje. Argument model, który jest stringiem definiującym model predykcji. Razem metoda pozwala definiować ścieżkę obliczeniową.\nMetoda pathsRemove musi pozwalać na usuwanie poprzednio zdefiniowanych ścieżek obliczeniowych. Metoda przyjmuje dowolną liczbę stringów definiujących ścieżki obliczeniowe.\nMetoda pathsList, która listuje zdefiniowane ścieżki.\nMetoda pathsRun, która przyjmuje argument pathName, który jest stringiem definiującym ścieżkę.\n\nMetoda ta wykonuje obliczenia dla zdefiniowanej ścieżki a więc w kolejności zdefiniowanej w ścieżce stosuje funkcje definiujące operacje i na końcu model obliczeniowy. Wynikiem jest więc prognoza dla szeregu czasowego.\n\nlibrary(dplyr)\ndetach(\"package:dplyr\", unload = TRUE)\n\n### Tworzenie danych do szeregu czasowego:\nts &lt;- yearmon(2009) + (0:(2 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 10 + cumsum(rnorm(2 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Dodawanie prostego modeli liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identycznościowego\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listing operacji i modeli\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Dodawanie ścieżki z modelem liniowym\ny$pathsAppend(\n  pathName = \"linear with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"linear_prediciton\"\n)\n\n### Dodawanie ścieżki z modelem identycznościowym / pozwala na\n### zobaczenia co dokładnie wchodzi do modelu predykcji\ny$pathsAppend(\n  pathName = \"identity with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"identity_prediction\"\n)\n\n### Listowanie zdefiniowanych ścieżek\n\ny$pathsList()\n\n  id                       name             operations               model\n1  1   linear with differencing differencing → na_omit   linear_prediciton\n2  2 identity with differencing differencing → na_omit identity_prediction\n\n### Obliczanie zdefiniowanych ścieżek\nz &lt;- y$pathsRun(pathName = \"identity with differencing\")\nzF &lt;- y$pathsRun(pathName = \"linear with differencing\")\n\n### Tworzenie wykresu na podstawie wyników\nggplot(\n  data = tibble(time = index(z), value = coredata(z)),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  geom_line(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  geom_point(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  coord_cartesian(ylim = c(-5, 5)) +\n  labs(title = \"Time series and forecast\") +\n  theme_light()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Igor Domaradzki",
    "section": "",
    "text": "Cześć! Witam na mojej stronie.\nJestem studentem SGH na kierunku magisterskim Analiza danych - big data. Wcześniej ukończyłem tam licencjat na kierunku Metody ilościowe w ekonomii i systemy informacyjne.\nMoje CV\nPoniżej kilka projektów, które stworzyłem.\n\n\n\nTo ja!\n\n\nStrona stworzona z użyciem RPosit Quarto.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorytm genetyczny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction Factory\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR6Class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]