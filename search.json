[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Projekty/RWrapped/index.html",
    "href": "Projekty/RWrapped/index.html",
    "title": "1. R Wrapped",
    "section": "",
    "text": "Projekt wykonany w języku R w ramach zajęć Prezentacja i wizualizacja danych"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#wprowadzenie",
    "href": "Projekty/RWrapped/index.html#wprowadzenie",
    "title": "1. R Wrapped",
    "section": "Wprowadzenie",
    "text": "Wprowadzenie\nLubię słuchać muzyki. Łącząc to z moim nauturalnym drugiem do analizy danych, od pewnego czasu dokładnie analizuję jaką muzykę słucham.\nNie jestem jedynym, który miał taki pomysł. Dla osób, które dokładnie chcą wiedzieć czego słuchają powstała strona &lt;last.fm&gt;. Tam, po połączeniu z kontem Spotify, można dokładnie zobaczyć co i o której zostało przesłuchane.\nPowstała nawet biblioteka w R autorstwa Piotra Patrzyka, która pozwala załadować dane ze swojego konta na lastFM w postaci data.frame w R\nDzięki tej bibliotece mogłem rozpocząć analizę.\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lubridate)\n#remotes::install_github(\"ppatrzyk/lastfmR\")\nlibrary(lastfmR)\n\nPodstawową funkcją tej biblioteki jest get_scrobbles.\n\nuser &lt;- \"c00lll\"\nscrobbles &lt;- get_scrobbles(user = user, timezone = 'Europe/Warsaw')\n\n\nhead(scrobbles,10)\n\n                   date         artist                     track\n               &lt;POSIXt&gt;         &lt;char&gt;                    &lt;char&gt;\n 1: 2024-11-01 13:54:23  Magdalena Bay                     Image\n 2: 2024-11-01 13:50:11  Magdalena Bay                     Image\n 3: 2024-11-01 13:42:38  Magdalena Bay                     Image\n 4: 2024-11-01 13:39:05  Magdalena Bay                     Image\n 5: 2024-11-01 13:35:33  Magdalena Bay                     Image\n 6: 2024-11-01 13:28:45           Lisa NEW WOMAN (feat. ROSALÍA)\n 7: 2024-11-01 13:13:20  Geordie Greep                Holy, Holy\n 8: 2024-11-01 13:03:22  Magdalena Bay                     Image\n 9: 2024-11-01 12:54:28 Snow Strippers          Under Your Spell\n10: 2024-11-01 12:50:07  Magdalena Bay                     Image\n                        album\n                       &lt;char&gt;\n 1:             Imaginal Disk\n 2:             Imaginal Disk\n 3:             Imaginal Disk\n 4:             Imaginal Disk\n 5:             Imaginal Disk\n 6: NEW WOMAN (feat. ROSALÍA)\n 7:             The New Sound\n 8:             Imaginal Disk\n 9:           April Mixtape 3\n10:             Imaginal Disk\n\n\nSortuje dane tak, aby najstarszy odsłuch był na górze. Potem zliczam, po raz który dany album/piosenka/artysta został odsłuchany. To przyda mi się później.\n\nscrobbles &lt;- scrobbles[(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles &lt;- scrobbles[rev(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles &lt;- scrobbles[(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles$jedynki &lt;- 1\nscrobbles$cum_sum &lt;- ave(scrobbles$jedynki, scrobbles$track, FUN=cumsum)\nscrobbles$cum_sum_artists &lt;- ave(scrobbles$jedynki, scrobbles$artist, FUN=cumsum)\nscrobbles$cum_sum_albums &lt;- ave(scrobbles$jedynki, scrobbles$album, FUN=cumsum)\nhead(scrobbles,10)\n\n                   date       artist  track         album jedynki cum_sum\n               &lt;POSIXt&gt;       &lt;char&gt; &lt;char&gt;        &lt;char&gt;   &lt;num&gt;   &lt;num&gt;\n 1: 2018-06-18 14:46:17 BROCKHAMPTON  JUNKY SATURATION II       1       1\n 2: 2018-06-18 14:51:57 BROCKHAMPTON   BANK    SATURATION       1       1\n 3: 2018-06-18 14:55:13 BROCKHAMPTON   TRIP    SATURATION       1       1\n 4: 2018-06-18 14:58:37 BROCKHAMPTON   STAR    SATURATION       1       1\n 5: 2018-06-18 15:01:18 BROCKHAMPTON   FAKE    SATURATION       1       1\n 6: 2018-06-18 22:47:18 BROCKHAMPTON   BANK    SATURATION       1       2\n 7: 2018-06-18 22:50:51 BROCKHAMPTON   TRIP    SATURATION       1       2\n 8: 2018-06-18 22:54:30 BROCKHAMPTON   STAR    SATURATION       1       2\n 9: 2018-06-18 22:56:05 BROCKHAMPTON   DIRT          Dirt       1       1\n10: 2018-06-19 00:00:01 BROCKHAMPTON   DIRT          Dirt       1       2\n    cum_sum_artists cum_sum_albums\n              &lt;num&gt;          &lt;num&gt;\n 1:               1              1\n 2:               2              1\n 3:               3              2\n 4:               4              3\n 5:               5              4\n 6:               6              5\n 7:               7              6\n 8:               8              7\n 9:               9              1\n10:              10              2"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#listy-top-10",
    "href": "Projekty/RWrapped/index.html#listy-top-10",
    "title": "1. R Wrapped",
    "section": "Listy Top 10",
    "text": "Listy Top 10\nUdało się! Teraz mogę wykonać analizy. Na początek zobaczmy, jakie jest 10 piosenek z największą liczbą odtworzeń.\n\n#sortoowanie tabeli pod względem piosenek\ncount_whole &lt;- table(scrobbles$track)\ncount_whole_sorted &lt;- sort(count_whole, decreasing = T)\n#Top 10 piosenek\ntop10_tracks_sorted &lt;- head(count_whole_sorted, 10)\n\n#wydruk w konsoli top 10 piosenek\nfor (i in 1:10) {\n  cat(paste0(i, \". \", scrobbles[track == names(top10_tracks_sorted[i])]$artist[2], \" - \", names(top10_tracks_sorted[i]),\": \", as.numeric(top10_tracks_sorted[i]), \"\\n\"))\n}\n\n1. Meek, Oh Why? - Pieśniarka i Król: 245\n2. 100 gecs - money machine: 242\n3. JPEGMAFIA - 1539 N. Calvert: 202\n4. 100 gecs - hand crushed by a mallet: 187\n5. Coals - Blue (feat. Schafter): 166\n6. 100 gecs - ringtone: 157\n7. 100 gecs - sympathy 4 the grinch: 148\n8. laura les - Haunted: 147\n9. ericdoa - movinglikeazombie - remix: 146\n10. QUEEF JERKY - PINEAPPLE UPSIDE DOWN: 143\n\nfor (i in 1:10) {\n  names(top10_tracks_sorted)[i] &lt;- paste0(scrobbles[track == names(top10_tracks_sorted[i])]$artist[2], \" - \", names(top10_tracks_sorted[i]))\n}\n\nZaprezentujmy to w formie jakiegoś wykresu.\n\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#050861\", \"#131ad6\"))\nvalues_barplot &lt;- as.numeric(rev(top10_tracks_sorted))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(top10_tracks_sorted), horiz = T, las = 1, yaxt = \"n\", xlim=c(0, max(scrobbles$cum_sum)), col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 utworów wszechczasów\")\ntext(as.numeric(rev(top10_tracks_sorted)), barplot_tracks, labels = as.numeric(rev(top10_tracks_sorted)), pos = 2, col = \"white\", cex = 3/4, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(top10_tracks_sorted))), pos = 4, col = \"white\", cex = 0.75, font = 2)\n\n\n\n\n\n\n\n\nTo samo powtarzam z artystami, a potem z albumami\n\ncount_artist &lt;- table(scrobbles$artist)\nartist_sorted &lt;- sort(count_artist, decreasing = T)\n#Top 10 artystów\ntop10_artist_sorted &lt;- head(artist_sorted,10)\nfor (i in 1:10) {\n  cat(i, \". \", names(top10_artist_sorted[i]),\": \", as.numeric(top10_artist_sorted[i]), \"\\n\", sep = \"\")\n}\n\n1. Taco Hemingway: 2774\n2. 100 gecs: 2450\n3. Holak: 2116\n4. JPEGMAFIA: 2104\n5. Meek, Oh Why?: 1939\n6. Charli XCX: 1768\n7. BROCKHAMPTON: 1692\n8. TV Girl: 1417\n9. Kendrick Lamar: 1294\n10. ROSALÍA: 1043\n\n\n\n#plot Top 10 artystow \npar(mar=c(5,2,2,2))\ntop10_artist_sorted &lt;- head(artist_sorted,10)\npal &lt;- colorRamp(c(\"#4f1403\", \"#992c0e\"))\nvalues_barplot &lt;- as.numeric(rev(top10_artist_sorted))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(top10_artist_sorted), horiz = T, las = 1, yaxt = \"n\", col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 artystów wszechczasów\")\ntext(as.numeric(rev(top10_artist_sorted)), barplot_tracks, labels = as.numeric(rev(top10_artist_sorted)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(top10_artist_sorted))), pos = 4, col = \"white\", cex = ((-0.2/3483)*(as.numeric(top10_artist_sorted[1] - top10_artist_sorted[10]) ) + 0.8), font = 2)\n\n\n\n\n\n\n\n\n\ncount_album &lt;- table(scrobbles$album)\nalbums_sorted &lt;- sort(count_album, decreasing = T)\n#Top 10 albumów\ntop10_albums_sorted &lt;- head(albums_sorted,10)\nfor (i in 1:10) {\n  cat(i, \". \", scrobbles[album == names(top10_albums_sorted[i])]$artist[2], \" - \", names(top10_albums_sorted[i]),\": \", as.numeric(top10_albums_sorted[i]), \"\\n\",sep = \"\")\n}\n\n1. Meek, Oh Why? - Zachód: 1129\n2. 100 gecs - 1000 gecs: 862\n3. Travis Scott - ASTROWORLD: 652\n4. 100 gecs - 1000 gecs and The Tree of Clues: 618\n5. BROCKHAMPTON - GINGER: 612\n6. Taco Hemingway - Café Belga: 571\n7. Taco Hemingway - Pocztówka z WWA, lato '19: 556\n8. Phoebe Bridgers - Punisher: 550\n9. Blood Orange - Negro Swan: 541\n10. JPEGMAFIA - Veteran: 537\n\nfor (i in 1:10) {\n  names(top10_albums_sorted)[i] &lt;- paste0(scrobbles[album == names(top10_albums_sorted[i])]$artist[2], \" - \", names(top10_albums_sorted[i]))\n}\n\n\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#004f1c\", \"#0fa343\"))\nvalues_barplot &lt;- as.numeric(rev(top10_albums_sorted))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(top10_albums_sorted), horiz = T, las = 1, yaxt = \"n\", col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 albumów wszechczasów\")\ntext(as.numeric(rev(top10_albums_sorted)), barplot_tracks, labels = as.numeric(rev(top10_albums_sorted)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(top10_albums_sorted))), pos = 4, col = \"white\", cex = 0.7, font = 2)"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#wyścigi-utworów",
    "href": "Projekty/RWrapped/index.html#wyścigi-utworów",
    "title": "1. R Wrapped",
    "section": "Wyścigi utworów",
    "text": "Wyścigi utworów\nPowyżesze wykresy przedstawiają stan aktualny (na wrzesień 2024). Natomiast moje preferencje z czasem się zmieniały. Rozpoczynając ten projekt, właśnie to chciałem zwizualizować.\nZobaczmy, jak zmieniali się liderzy w klasyfikacji odsłuchań.\n\n#############\n#Wyścig utworów\ntop_track &lt;- scrobbles[track == names(count_whole_sorted[1]),]\n\nplot(top_track$date, top_track$cum_sum, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Czas odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń utworów\")\n\nfor (track_name in names(count_whole_sorted[1:1000])) {\n  to_draw &lt;- scrobbles[track == track_name,]\n  lines(to_draw$date, to_draw$cum_sum, type = \"s\", col = \"#dbd7ca\")\n}\n\nlines(top_track$date, top_track$cum_sum, type = \"s\", col = \"gold\", lwd=3)\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_draw &lt;- scrobbles[track == names(count_whole_sorted[i]),]\n  lines(to_draw$date, to_draw$cum_sum, type = \"s\", col = \"black\")\n}\n\ntop_track3 &lt;- scrobbles[track == names(count_whole_sorted[3]),]\nlines(top_track3$date, top_track3$cum_sum, type = \"s\", col = \"brown\", lwd = 3)\n\ntop_track2 &lt;- scrobbles[track == names(count_whole_sorted[2]),]\nlines(top_track2$date, top_track2$cum_sum, type = \"s\", col = \"grey\", lwd = 3)\n\nlines(top_track$date, top_track$cum_sum, type = \"s\", col = \"gold\", lwd=3)\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum), c(names(count_whole_sorted[1]), names(count_whole_sorted[2]), names(count_whole_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.6, title=\"Nazwy utworów\", text.font=1) \n\n\n\n\n\n\n\n\nNajbardziej zaciekawił mnie trend, w którym wszystkie piosenki mają wielki wyskok na początku, po którym następuje zwolnienie. Jest to jak najbardziej spodziewane, ponieważ po pewnym czasie piosenki tracą na “świeżości” i przechodzę do kolejnej.\n\n#############\n#Wyścig artystow\ntop_artist &lt;- scrobbles[artist == names(artist_sorted[1]),]\n\nplot(top_artist$date, top_artist$cum_sum_artists, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Czas odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń artystow\")\n\n\nfor (artist_name in names(artist_sorted[1:1000])) {\n  to_draw &lt;- scrobbles[artist == artist_name,]\n  lines(to_draw$date, to_draw$cum_sum_artists, type = \"s\", col = \"#dbd7ca\")\n}\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_draw &lt;- scrobbles[artist == names(artist_sorted[i]),]\n  lines(to_draw$date, to_draw$cum_sum_artists, type = \"s\", col = \"black\")\n}\n\ntop_artist3 &lt;- scrobbles[artist  == names(artist_sorted[3]),]\nlines(top_artist3$date, top_artist3$cum_sum_artists, type = \"s\", col = \"brown\", lwd = 3)\n\ntop_artist2 &lt;- scrobbles[artist  == names(artist_sorted[2]),]\n\nlines(top_artist2$date, top_artist2$cum_sum_artists, type = \"s\", col = \"grey\", lwd = 3)\nlines(top_artist$date, top_artist$cum_sum_artists, type = \"s\", col = \"gold\", lwd=3)\n\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum_artists), c(names(artist_sorted[1]), names(artist_sorted[2]), names(artist_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.6, title=\"Nazwy artystów\", text.font=1) \n\n\n\n\n\n\n\n\n\n#####\n#Wyścig  albumów\ntop_album &lt;- scrobbles[album == names(albums_sorted[1]),]\n\nplot(top_album$date, top_album$cum_sum_albums, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Moment odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń albumów\")\n\nfor (album_name in names(albums_sorted[1:1000])) {\n  to_draw &lt;- scrobbles[album == album_name,]\n  lines(to_draw$date, to_draw$cum_sum_albums, type = \"s\", col = \"#dbd7ca\")\n}\n\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_draw &lt;- scrobbles[album == names(albums_sorted[i]),]\n  lines(to_draw$date, to_draw$cum_sum_albums, type = \"s\", col = \"black\")\n}\n\n\ntop_album3 &lt;- scrobbles[album  == names(albums_sorted[3]),]\nlines(top_album3$date, top_album3$cum_sum_albums, type = \"s\", col = \"brown\", lwd = 3)\n\ntop_album2 &lt;- scrobbles[album  == names(albums_sorted[2]),]\nlines(top_album2$date, top_album2$cum_sum_albums, type = \"s\", col = \"grey\", lwd = 3)\n\nlines(top_album$date, top_album$cum_sum_albums, type = \"s\", col = \"gold\", lwd=3)\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum_albums), c(names(albums_sorted[1]), names(albums_sorted[2]), names(albums_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.7, title=\"Nazwy albumów\", text.font=1)"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#ggplot2",
    "href": "Projekty/RWrapped/index.html#ggplot2",
    "title": "1. R Wrapped",
    "section": "ggplot2",
    "text": "ggplot2\nInną rzeczą, którą chciałem sprawdzić jest to jak zmieniały się moje nawyki melomana podczas okresu zbierania danych. Czy teraz słucham więcej muzyki niż kiedyś?\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\nscrobbles_copy &lt;- scrobbles\n\ntibble_months &lt;- (scrobbles_copy  %&gt;% \n         group_by(month = lubridate::floor_date(date, 'month')) %&gt;%\n         summarize(l_wystapien = sum(jedynki)))\n\ntibble_months$month_name &lt;- month(tibble_months$month)\ntibble_months$year  &lt;- year(tibble_months$month)\n\nfirst_year &lt;- tibble_months$year |&gt; head(1)\ncurrent_year &lt;- tibble_months$year |&gt; tail(1)\n# Heatmap \nggplot(tibble_months, aes(year, month_name)) + \n  geom_tile(aes(fill= l_wystapien), col = \"white\") +\n  scale_fill_gradient(low = \"#fac8d8\", high = \"#87002b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań danego miesiąca\") +\n  scale_y_reverse() + scale_x_discrete(limits=first_year:current_year)+\n  xlab(\"Rok\") + ylab(\"Miesiąc\")\n\n\n\n\n\n\n\n#heatmap z wartosciami\nggplot(tibble_months, aes(year, month_name)) + \n  geom_tile(aes(fill= l_wystapien), col = \"white\") +\n  scale_fill_gradient(low = \"#fac8d8\", high = \"#87002b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań danego miesiąca\") +\n  scale_x_discrete(limits=first_year:current_year)+\n  xlab(\"Rok\") + ylab(\"Miesiąc\") + \n  geom_text(aes(label = l_wystapien), col = \"white\", cex = 4.5) +\n  scale_y_reverse()\n\n\n\n\n\n\n\n\nJednak więcej słuchałem kiedyś… Co ciekawe po rozpoczęciu pandemii w marcu 2020 roku liczba odtworzeń się drastycznie zmniejszyła. Można się było spodziewać, że miałem więcej wolengo czasu na słuchanie muzyki, lecz to jednak słuchanie muzyki w drodze do szkoły czy pracy nakręcało największe liczby.\nInnym pytaniem jest co wydarzyło się w czerwcu 2024 roku? Był to dla mnie intensywny okres sesji, podczas którego wspomagałem się muzyką. Natomiast rozmiar tego wsparcia mocno mnie zaskoczył!\nJacy sąc najczęsciej słuchani artyści w każdym miesiącu?\n\n### najpopularniejsci artysci dla kazdego miesiaca\nlibrary(zoo)\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:data.table':\n\n    yearmon, yearqtr\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\nfirst_scrobble_date &lt;- scrobbles$date[1]\nn_months &lt;- 1 + interval(as.yearmon(first_scrobble_date), today()) %/% months(1)\ndetach(\"package:zoo\", unload = TRUE)\n#rządy to miesiące, kolumny to lata\n# Pierwsszy rok, nie musial sie zaczac w styczniu\nfirst_scrobble_date_month &lt;- month(first_scrobble_date)\nliczbLat &lt;- ceiling((n_months - first_scrobble_date_month)/12) + 1\nmacierz &lt;- matrix(NA, nrow = 12, ncol = liczbLat)\nmacierz_to_plot &lt;- matrix(NA, n_months, 2)\ndate_temp &lt;- min(scrobbles_copy$date)\ndate_temp &lt;- floor_date(date_temp, 'month')\ndate_temp_next &lt;- date_temp %m+% months(1)\npier_mies = first_scrobble_date_month\nfor (i in 1:n_months) {\n  month_in_scr &lt;- scrobbles[scrobbles$date &gt; date_temp & scrobbles$date &lt; date_temp_next]\n  t_month_in_scr &lt;- table(month_in_scr$artist)\n  t_month_in_scr &lt;- sort(t_month_in_scr, decreasing = T)\n  naj_artysta &lt;- names(t_month_in_scr[1])\n  if (is.null(naj_artysta)) {\n    naj_artysta = \"No data for this month\"\n    ich_odtworzenia_wtedy = 0\n    } else {\n  ich_odtworzenia_wtedy &lt;- as.numeric(t_month_in_scr[1])\n    }\n  date_temp_next &lt;- date_temp_next %m+% months(1)\n  date_temp &lt;- date_temp %m+% months(1)\n  macierz[pier_mies] = naj_artysta\n  macierz_to_plot[pier_mies-first_scrobble_date_month+1, 1] = substr(naj_artysta,1,26)\n  macierz_to_plot[pier_mies-first_scrobble_date_month+1, 2] = ich_odtworzenia_wtedy\n  pier_mies &lt;- pier_mies + 1\n}\n#macierz\n#macierz_to_plot\ncolnames(macierz) &lt;- year(first_scrobble_date):year(tail(scrobbles$date,1))\nrownames(macierz) &lt;- c(\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\")\n\n\ndf_barplot &lt;- as.data.frame(macierz_to_plot)\n\n## To add, if len(df_barplot) != len(tibble_months), go by row in tibble months and ad missing months\ndf_barplot$month_name &lt;- tibble_months$month_name\ndf_barplot$year &lt;- tibble_months$year\n\nnames(df_barplot)[1:2] &lt;- c(\"Artysta\", \"Wystapienia_w_mies\")\n\ntibble_barplot &lt;- as_tibble(df_barplot)\ntibble_barplot$Wystapienia_w_mies &lt;- as.double(tibble_barplot$Wystapienia_w_mies)\n\ng &lt;- ggplot(tibble_barplot, aes(year, as.numeric(month_name))) + \n  geom_tile(aes(fill= as.double(Wystapienia_w_mies)), col = \"white\") +\n  scale_fill_gradient(low = \"#e5ced4\", high = \"#451350\", name = \"Odtworzenia \\n w miesiącu\") +\n  ggtitle(\"Liczba odsłuchań najczęściej słuchanego artysty danego miesiąca\") +\n  scale_x_discrete(limits=year(first_scrobble_date):year(tail(scrobbles$date,1)))+\n  xlab(\"Rok\") + ylab(\"Miesiąc\") +\n  scale_y_reverse() +\n  geom_text(aes(label = substr(Artysta, 1, 14)), col = \"white\", size = 1.7, font = 2)\ng\n\n\n\n\n\n\n\n\nDzięki temu wykresowi możemy zobaczyć, że do wysokiego wyniku w czerwcu 2024 przyczyniłą się również premiera nowego albumu Charli XCX pt. “brat”\nSpójrzmy w jakich miesiącach roku, słuchałem najwięcej.\n\n#Średnia Liczba odtworzeń na miesiąc\nsrednie_wartosci &lt;- tibble_months %&gt;%\n  group_by(month_name) %&gt;%\n  summarise(SredniaWartosc = mean(l_wystapien))\n\nsrednie_wartosci &lt;- setNames(srednie_wartosci, c(\"Miesiąc\", \"Średnia Liczba odtworzeń na miesiąc\"))\nsrednie_wartosci$Miesiąc &lt;- factor(month.name[srednie_wartosci$Miesiąc], levels = month.name)\n\n\npar(mar=c(5,6,3,3))\npal &lt;- colorRamp(c(\"#37420D\", \"#9CBD26\"))\nvalues_barplot &lt;- as.numeric(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_mies &lt;- barplot(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`), names = rev(srednie_wartosci$Miesiąc), las = 1, xlim=c(0,max(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`)), horiz = T, col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Średnia liczba odtworzeń w miesiącu\")\ntext(((max(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`))/30), barplot_mies, labels = round(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`)), col = \"white\", font = 2, cex = 0.9)\n\n\n\n\n\n\n\n\nOraz sprójrzmy w jakich latach słuchałem najwięcej\n\nby_year &lt;- aggregate(l_wystapien ~ year, data=tibble_months, sum)\n#Todo: if a year is missing, add it and count 0\nby_year &lt;- setNames(by_year, c(\"Rok\", \"Liczba odtworzeń\"))\n\nbarplot_przed_usr &lt;- barplot(by_year[,2], names = by_year[,1], ylim = c(0,18000), main = \"Liczba odtworzeń w ciągu roku\", col = \"#aa5555\")\ntext(barplot_przed_usr, by_year[,2] + 650, labels = by_year[,2])\n\n\n\n\n\n\n\n#Srednia odtworzen na miesiąc podczas danego roku\nby_year$l_miesiecy &lt;-c(12 - first_scrobble_date_month + 1,rep(12, length.out = floor((n_months - (12 - first_scrobble_date_month + 1))/12)),(n_months - (12 - first_scrobble_date_month + 1)) %% 12)\n\nby_year$na_mies &lt;- by_year$`Liczba odtworzeń` / by_year$l_miesiecy\nby_year$na_mies &lt;- round(by_year$na_mies,0)\n#t(by_year)\npokaz_by_year &lt;- t(by_year[c(1,4)])\n#pokaz_by_year\nbarplot_lata &lt;- barplot(pokaz_by_year[2,], names = pokaz_by_year[1,], col = \"#aa5555\", ylim=c(0,1500), main = \"Średnia liczba odtworzeń na miesiąc\")\ntext(barplot_lata, pokaz_by_year[2,] + 50, labels = pokaz_by_year[2,])\n\n\n\n\n\n\n\n\nTeraz zobaczmy, w jakich godzinach dnia najczęściej słucham muzyki.\n\nlibrary(lubridate)\n#heat map dzien/godzina\nday_plot &lt;- (scrobbles_copy  %&gt;% \n         group_by(date = lubridate::floor_date(date, 'hour')) %&gt;%\n         summarize(l_wystapien = sum(jedynki)))\n\n#day_plot$day &lt;- wday(day_plot$date, week_start = getOption(\"lubridate.week.start\", 1))\n\nday_plot$day &lt;- wday(day_plot$date - days(1))\nday_plot$hour  &lt;- hour(day_plot$date)\n\nday_plot_to_draw &lt;- day_plot %&gt;%\n  group_by(day, hour) %&gt;%\n  summarise(Suma = sum(l_wystapien))\n\n`summarise()` has grouped output by 'day'. You can override using the `.groups`\nargument.\n\n# Heatmap \ng &lt;- ggplot(day_plot_to_draw, aes(day, hour)) + \n  geom_tile(aes(fill= Suma), col = \"white\") +\n  scale_fill_gradient(low = \"#fad8e8\", high = \"#67000b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań o danej pory dnia\")  + scale_x_discrete(limits=1:7, labels = c(\"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\", \"Niedziela\")) +\n  scale_y_discrete(limits=0:23) + xlab(\"Dzień tygodnia\") + ylab(\"Godzina\")\ng\n\n\n\n\n\n\n\n#dodanie wartości na mapę\ng + geom_text(aes(label = Suma), col = \"white\", cex = 3)\n\n\n\n\n\n\n\n# dzien i godzina z najwieksza iloscia odsłuchań\n#day_plot_to_draw[which.max(day_plot_to_draw$Suma),]\n\nKrólują godziny popołudniowe powrotu ze szkoły i pracy. Najwięcej we wtorek o godz. 17."
  },
  {
    "objectID": "Projekty/RWrapped/index.html#chmura-gatunków",
    "href": "Projekty/RWrapped/index.html#chmura-gatunków",
    "title": "1. R Wrapped",
    "section": "Chmura gatunków",
    "text": "Chmura gatunków\nZobaczmy jakie gatunki najczęsciej się przewijają u artysów, których słucham.\n\nartist_info &lt;- get_library_info(user = user)\n\n\nlibrary(stringr)\nlibrary(wordcloud)\n\nLoading required package: RColorBrewer\n\n#wordcloud\n\nartist_info$genres &lt;- str_split(artist_info$artist_tags, \"; \")\ngenres_unlisted &lt;- unlist(artist_info$genres)\n\n# Utworzenie tabeli częstości gatunków\ntabela_czestosci_gatunkow &lt;- table(genres_unlisted)\nlista_nazw_gat &lt;- names(tabela_czestosci_gatunkow)\n\n#chmura słów\npar(mar=c(2,2,2,2))\nwordcloud(lista_nazw_gat, as.numeric(tabela_czestosci_gatunkow), colors = c(\"#101112\", \"#384a8c\", \"#db8904\"))\n\n\n\n\n\n\n\n\n\nnajczestszy_gatunek &lt;- names(tabela_czestosci_gatunkow)[which.max(tabela_czestosci_gatunkow)]\n\ntest_cgest &lt;- rev(sort(tabela_czestosci_gatunkow, deacreasing = T))\n#test_cgest[1]\n\n# Lista najczęstszych gatunków wśrod artystów\nfor (i in 1:10){\n  cat(paste0(i, \". \", names(test_cgest[i]), \": \", as.numeric(test_cgest[i]), \"\\n\"))\n}\n\n1. electronic: 345\n2. Hip-Hop: 321\n3. rap: 297\n4. seen live: 279\n5. pop: 224\n6. indie: 203\n7. hip hop: 153\n8. experimental: 114\n9. hyperpop: 111\n10. female vocalists: 110\n\ntc &lt;- head(test_cgest,10)\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#050861\", \"#131ad6\"))\nvalues_barplot &lt;- as.numeric(rev(tc))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(tc), horiz = T, las = 1, yaxt = \"n\", col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Najczęstrze tagi wśród artystów\")\ntext(as.numeric(rev(tc)), barplot_tracks, labels = as.numeric(rev(tc)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(tc))), pos = 4, col = \"white\", cex = 0.8, font = 2)"
  },
  {
    "objectID": "Projekty/R6Class/index.html",
    "href": "Projekty/R6Class/index.html",
    "title": "4. R6Class",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\nOpis projektu\nProjekt dotyczy rozszerzonej reprezentacji szeregu czasowego. W języku R jest wiele możliwości reprezentowania szeregów czasowych. Podstawowe klasy to ts i mts. Klasy, które rozszerzają te klasy to zoo i xts. Wszystkie te klasy reprezentują jedynie dane a więc dane dotyczące czasu i wartości. W tym projekcie chcemy do danych dołożyć operacje, które są wykonywane na szeregach czasowych oraz metody, które tworzą prognozy.\nTechnicznie, zadaniem w projekcie jest zdefiniowanie klasy timeSeries w modelu obiektowym R6, która na podstawie wektora określającego czas i wektora wartości, inicjalizuje instancję klasy. Metoda new powinna przyjmować dwa argumenty: times, który przyjmuje wektor czasów (i tutaj możemy wykorzystać dowolną klasę reprezentującą datę i czas, np. Date czy yearmon) oraz values, który przyjmuje wektor wartości.\nKlasa musi oferować następujące podstawowe metody.\n\nMetoda getTimes, która zwraca podany wektor czasów.\nMetoda getValues, która zwraca podany wektor wartości.\nMetoda getTimeSeries, która zwraca szereg czasowy. W rozwiązaniu proszę wykorzystać klasę xts.\n\nProjekt jest zatem rozszerzeniem klasy xts.\nPowyższe metody są typowymi fundamentalnymi metodami związanymi z szeregiem czasowym.\n\n\nMoja definicja funkcji\n\nlibrary(R6)\nlibrary(xts)\nlibrary(zoo)\nlibrary(tibble)\nlibrary(ggplot2)\n\ntimeSeries &lt;- R6Class(\n  classname = \"timeSeries\",\n  public = list(\n    times = NA,\n    values = NA,\n    table = NULL,\n    operations = list(),\n    models = list(),\n    paths = list(),\n    initialize = function(times, values) {\n      self$times &lt;- times\n      self$values &lt;- values\n      self$table &lt;- xts::xts(x = self$values, order.by = self$times)\n    },\n    \n    getTimes = function() {\n      self$times\n    },\n    \n    getValues = function() {\n      self$values\n    },\n    \n    getTimeSeries = function() {\n      self$table\n    },\n    \n    opsAppend = function(...) {\n      ops &lt;- list(...)\n      for (name in names(ops)) {\n        self$operations[[name]] &lt;- ops[[name]]\n      }\n    },\n    \n    opsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$operations[[key]] &lt;- NULL\n      }\n    },\n    \n    opsList = function() {\n      data.frame(id = seq_along(self$operations), name = names(self$operations))\n    },\n    modelsAppend = function(...){\n      model &lt;- list(...)\n      for (name in names(model)) {\n        self$models[[name]] &lt;- model[[name]]\n      }\n    },\n    modelsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$models[[key]] &lt;- NULL\n      }\n    },\n    modelsList = function() {\n      data.frame(id = seq_along(self$models), name = names(self$models))\n    },\n    pathsAppend = function(pathName, operations, model){\n      self$paths[[pathName]] &lt;- list(operations = operations, model = model)\n      },\n    pathsRemove = function(...) {\n      pathNames &lt;- list(...)\n      for (pathName in pathNames) {\n        self$paths[[pathName]] &lt;- NULL\n      }\n    },\n    pathsList = function() {\n      paths_df &lt;- do.call(rbind, lapply(names(self$paths), function(name) {\n        data.frame(\n          id = which(names(self$paths) == name),\n          name = name,\n          operations = paste(self$paths[[name]]$operations, collapse = \" → \"),\n          model = self$paths[[name]]$model,\n          stringsAsFactors = FALSE\n        )\n      }))\n      paths_df\n    },\n    pathsRun = function(pathName) {\n      if (!(pathName %in% names(self$paths))) {\n        stop(\"Path not found.\")\n      }\n      path &lt;- self$paths[[pathName]]\n      result &lt;- self$table\n      for (op in path$operations) {\n        result &lt;- self$operations[[op]](result)\n      }\n      prediction &lt;- self$models[[path$model]](result)\n      prediction\n    }\n    \n  )\n)\n\n\n\nPrzykłady\n\nPrzykład 1\nPoniższy przykład tworzy bardzo prosty szereg czasowy i pokazuje działanie opisanych powyżej metod.\nPrzykład pokazuje inicjalizację obiektu klasy timeSeries oraz wykorzytanie podstawowych metod. Na tej podstawie tworzony jest prosty wykres szeregu czasowego.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Pobranie wartości\ny$getValues()\n\n [1]  0.26021284  1.16199304  2.47939770  2.00716160  0.76597009 -0.15854317\n [7] -0.52916720  0.03421263  0.97040936  0.16622558 -0.84301308 -0.14358727\n[13]  1.46782773  1.45841425  1.33027973  2.33636610  1.75482072  0.86506666\n[19]  0.99074161  1.61091188  2.46843299  2.51689921  2.54398136  1.43614021\n[25]  1.59882988  1.39159448  0.59898084  0.38483126  0.84189485  2.53269847\n[31]  2.64367853  2.28546706  2.87011557  2.84004309  3.33906710  4.44595122\n[37]  5.41109358  6.20815419  5.24568069  4.29348128  2.48834882  2.91033389\n[43]  2.93590334  3.98008689  5.94854331  6.31558505  5.69791876  3.50427461\n[49]  4.64032692  5.59156407  6.20492238  5.49778449  4.94889682  5.78327106\n[55]  7.33757551  7.19740614  6.09388790  8.32681736  9.48018873  9.87088540\n\n### Pobranie wektora czasów\ny$getTimes()\n\n [1] \"Jan 2009\" \"Feb 2009\" \"Mar 2009\" \"Apr 2009\" \"May 2009\" \"Jun 2009\"\n [7] \"Jul 2009\" \"Aug 2009\" \"Sep 2009\" \"Oct 2009\" \"Nov 2009\" \"Dec 2009\"\n[13] \"Jan 2010\" \"Feb 2010\" \"Mar 2010\" \"Apr 2010\" \"May 2010\" \"Jun 2010\"\n[19] \"Jul 2010\" \"Aug 2010\" \"Sep 2010\" \"Oct 2010\" \"Nov 2010\" \"Dec 2010\"\n[25] \"Jan 2011\" \"Feb 2011\" \"Mar 2011\" \"Apr 2011\" \"May 2011\" \"Jun 2011\"\n[31] \"Jul 2011\" \"Aug 2011\" \"Sep 2011\" \"Oct 2011\" \"Nov 2011\" \"Dec 2011\"\n[37] \"Jan 2012\" \"Feb 2012\" \"Mar 2012\" \"Apr 2012\" \"May 2012\" \"Jun 2012\"\n[43] \"Jul 2012\" \"Aug 2012\" \"Sep 2012\" \"Oct 2012\" \"Nov 2012\" \"Dec 2012\"\n[49] \"Jan 2013\" \"Feb 2013\" \"Mar 2013\" \"Apr 2013\" \"May 2013\" \"Jun 2013\"\n[55] \"Jul 2013\" \"Aug 2013\" \"Sep 2013\" \"Oct 2013\" \"Nov 2013\" \"Dec 2013\"\n\n### Pobranie szeregu czasowgo (klasa xts)\nhead(y$getTimeSeries(),10)\n\n                [,1]\nJan 2009  0.26021284\nFeb 2009  1.16199304\nMar 2009  2.47939770\nApr 2009  2.00716160\nMay 2009  0.76597009\nJun 2009 -0.15854317\nJul 2009 -0.52916720\nAug 2009  0.03421263\nSep 2009  0.97040936\nOct 2009  0.16622558\n\n### Stworzenie przykładowego wykresu\nggplot(\n  data = tibble(time = y$getTimes(), value = y$getValues()),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Example of a time series\") +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nPrzykład 2\nPodstawowe metody, opisane powyżej, nie wyczerpują operacji, które chcemy dodać do szeregu czasowego. Oczywiście katalog potencjalnych operacji nie jest skończony więc nie możemy dodać metod reprezentujących wszystkie potencjalne operacje. Z tego powodu chcemy mieć możliwość dodawania dowolnych operacji i następnie wiązania tych operacji. W pierwszej kolejności chcemy zbudować prosty system zarządzania operacjami. Na potrzeby tego projektu, operacja na szeregu czasowym, to dowolna funkcja, która jako argument przyjmuje szereg czasowy (klasa xts) i zwraca szereg czasowy (ponownie klasa xts). Tak więc musimy mieć następujące metody.\n\nMetoda opsAppend do dodawania operacji. Składania tej metody powinna być identyczna ze składnią funkcji list. Konieczne jest podanie kluczy jednoznacznie identyfikujących\nMetoda opsRemove do usuwania operacji. Metoda przyjmuje dowolną liczbę stringów, które są kluczami usuwanych operacji.\nMetoda opsList, która listuje operacje, które aktualnie są w liście dodanych operacji.\n\nPoniższy przykład pokazuje metody dodawania, listowania i usuwania operacji.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy operacje.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\n### Usuwanie operacji\ny$opsRemove(\"logs_abs\")\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2      na_omit\n\n\n\n\nPrzykład 3\nKolejnym elementem, które musi się znaleźć w klasie jest model predykcji. Na potrzeby tego projektu, przez model predkcji będziemy rozumieli dowolną funkcję, która jako argument przyjmuje obiekt klasy xts i zwraca obiekt tej klasy. Ponownie, katalog możliwych modeli predykcji nie jest zamknięty, więc również musimy mieć prosty system zarządzania. W szczególności klasa musi oferować następujące metody.\n\nMetoda modelsAppend, która pozwala na dodawanie modeli. Składnia tej metody powinna być taka jak funkcji list. Podobnie jak poporzednio, konieczne jest podanie unikalnych kluczy indetyfikujących modele.\nMetoda modelsRemove, która pozwana na usunięcie modeli. Metoda musi przyjmować stringi, które definiują dodane modele.\nMetoda modelsList, która listuje dodane modele.\n\nPoniższy przykład pokazuje zastosowanie opisanych metod.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy modele.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie prostego modelu liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identyczności\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listowanie modelu\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Usuwanie modelu\ny$modelsRemove(\"identity_prediction\")\n\n### Listowanie modelu\ny$modelsList()\n\n  id              name\n1  1 linear_prediciton\n\n\n\n\nPrzykład 4\nSame operacje oraz modele nic nie robią. Kolejne zadanie to wiązanie operatorów i kończenie ich modelami predykcji. Powiązanie takie ma postać szereg czasowy → operator 1 → operator 2 → … → operator n → model. Każde takie powiązanie nazywamy dalej ścieżką obliczeniową (path). Klasa musi mieć narzędzia do tworzenia i zarządzania takimi ścieżkami obliczeniowymi. Klasa musi oferować następujące metody.\n\nMetoda pathsAppend musi pozwalać dodawać ścieżki obliczeniowe. Metoda ta powinna przyjmować trzy argumenty. Argument pathName, który jest stringiem i jest unikalny. Argument operations, który jest wektorem stringów definiujących dodane operacje. Argument model, który jest stringiem definiującym model predykcji. Razem metoda pozwala definiować ścieżkę obliczeniową.\nMetoda pathsRemove musi pozwalać na usuwanie poprzednio zdefiniowanych ścieżek obliczeniowych. Metoda przyjmuje dowolną liczbę stringów definiujących ścieżki obliczeniowe.\nMetoda pathsList, która listuje zdefiniowane ścieżki.\nMetoda pathsRun, która przyjmuje argument pathName, który jest stringiem definiującym ścieżkę.\n\nMetoda ta wykonuje obliczenia dla zdefiniowanej ścieżki a więc w kolejności zdefiniowanej w ścieżce stosuje funkcje definiujące operacje i na końcu model obliczeniowy. Wynikiem jest więc prognoza dla szeregu czasowego.\n\nlibrary(dplyr)\ndetach(\"package:dplyr\", unload = TRUE)\n\n### Tworzenie danych do szeregu czasowego:\nts &lt;- yearmon(2009) + (0:(2 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 10 + cumsum(rnorm(2 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Dodawanie prostego modeli liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identycznościowego\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listing operacji i modeli\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Dodawanie ścieżki z modelem liniowym\ny$pathsAppend(\n  pathName = \"linear with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"linear_prediciton\"\n)\n\n### Dodawanie ścieżki z modelem identycznościowym / pozwala na\n### zobaczenia co dokładnie wchodzi do modelu predykcji\ny$pathsAppend(\n  pathName = \"identity with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"identity_prediction\"\n)\n\n### Listowanie zdefiniowanych ścieżek\n\ny$pathsList()\n\n  id                       name             operations               model\n1  1   linear with differencing differencing → na_omit   linear_prediciton\n2  2 identity with differencing differencing → na_omit identity_prediction\n\n### Obliczanie zdefiniowanych ścieżek\nz &lt;- y$pathsRun(pathName = \"identity with differencing\")\nzF &lt;- y$pathsRun(pathName = \"linear with differencing\")\n\n### Tworzenie wykresu na podstawie wyników\nggplot(\n  data = tibble(time = index(z), value = coredata(z)),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  geom_line(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  geom_point(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  coord_cartesian(ylim = c(-5, 5)) +\n  labs(title = \"Time series and forecast\") +\n  theme_light()"
  },
  {
    "objectID": "Projekty/GA/index.html",
    "href": "Projekty/GA/index.html",
    "title": "3. Algorytm genetyczny",
    "section": "",
    "text": "Projekt wykonany w Pythonie na zajęcia Credit Scoring.\nPodstawowym zagadnieniem było zbudowanie modelu do oceny ryzyka potencjalnych klientów kredytowych za pomocą kodów udostępnionych przez wykłądowcę, pana dr Karola Przanowskiego. Dla chętnych była możliowość ich udoskonalenia wg własnej inwencji twórczej. Ja zdecydowałem się zaimplementować algorytm genetyczny do wyboru zmiennych modelu.\nDo wyboru w danych mieliśmy ok. 200 zmiennych, podczas gdy do modelu szukaliśmy najlepszej kombinacji kilku/kilkunastu. Funkcją celu było znalezienie modelu z jak największym indeksem Gini, mierzącym jego siłę predykcyjną.\nPełny kontekst dla kodu poniżej można znaleźc tutaj."
  },
  {
    "objectID": "Projekty/Integrate3d/index.html",
    "href": "Projekty/Integrate3d/index.html",
    "title": "6. Całki podwójne",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Podstawy programowania w języku R."
  },
  {
    "objectID": "Projekty/Integrate3d/index.html#opis-projektu",
    "href": "Projekty/Integrate3d/index.html#opis-projektu",
    "title": "6. Całki podwójne",
    "section": "Opis projektu",
    "text": "Opis projektu\nZadanie w tym projekcie jest raczej proste i dotyczy obliczania całek z funkcji f:R^2 -&gt; R na przedziałach.\nW tym celu chcemy zdefiniować funkcję, która przyjmuje dwa główne argumenty: pierwszy reprezentujący matematyczną funkcję, która będzie całkowana oraz drugi, który reprezentuje przedział całkowania. Funkcja może przyjmować dodatkowe argumenty w zależności od wykorzystanego algorytmu (przykład podany poniżej). Funkcja powinna zwracać wartość obliczonej całki.\nZ technicznego punktu widzenia, chcemy zdefiowanować funkcję integrate3d(), która przyjmuje dwa argumenty:\n\nf funkcja, która jest całkowana, np., f(x,y) {x ^ 2 + y ^ 2};\nover lista zawierająca dwie pozycje, reprezentująca przedział całkowania, np., list(x = c(0,1), y = c(0, 1))."
  },
  {
    "objectID": "Projekty/Integrate3d/index.html#moje-rozwiązanie",
    "href": "Projekty/Integrate3d/index.html#moje-rozwiązanie",
    "title": "6. Całki podwójne",
    "section": "Moje rozwiązanie",
    "text": "Moje rozwiązanie\nCałka jest obliczana metodą prostokątów. Z racji, że w zadaniu liczymy całki podówjne można też mówić o metodzie równoległoboków.\n\n# Zadanie 3 \nintegrate3d &lt;- function(f, over, n = 120) {\n  # Dzielimy przestrzeń, na której całkujemy na n^2 części\n  axis_x &lt;- seq(over$x[1], over$x[2], length.out = n)\n  axis_y &lt;- seq(over$y[1], over$y[2], length.out = n)\n  \n  #Liczymy wartość całki w poszczególnych punktach i dodajemy objętości kolejnych prostopadłościanów do siebie\n  integral_sum &lt;- 0\n  for (xx in 1:(n-1)){\n    smaller_x &lt;- axis_x[xx]\n    bigger_x &lt;- axis_x[xx+1]\n    avg_x &lt;- mean(smaller_x,bigger_x)\n    for (yy in 1:(n-1)) {\n      smaller_y &lt;- axis_y[yy]\n      bigger_y &lt;- axis_y[yy+1]\n      avg_y &lt;- mean(smaller_y,bigger_y)\n      z &lt;- f(avg_x, avg_y)\n      parrallelogram_volume &lt;- (bigger_y - smaller_y)*(bigger_x - smaller_x)*z\n      integral_sum &lt;- integral_sum + parrallelogram_volume\n    }\n  }\n  return(integral_sum)\n}"
  },
  {
    "objectID": "Projekty/Integrate3d/index.html#przykłady",
    "href": "Projekty/Integrate3d/index.html#przykłady",
    "title": "6. Całki podwójne",
    "section": "Przykłady",
    "text": "Przykłady\n\n### Example 1\nintegrate3d(\n  f = function(x, y) {cos(x) * y},\n  over = list(x = c(0, pi / 2), y = c(0, 1)))\n\n[1] 0.4990634\n\n\n\n### Example 2\nintegrate3d(\n  f = function(x, y) { (cos(x) + 2) * (sin(y) + 1)},\n  over = list(x = c(0, pi), y = c(0, pi)),\n  n = 10^2)\n\n[1] 32.46768\n\n\n\n### Example 2\nintegrate3d(\n  f = function(x, y) {30 + 23*x + (13/4)*y + (28.12)*x*y - 144 * sqrt(x^2 + y^2)},\n  over = list(x = c(0, (5 * pi) / 2), y = c(0, 5)))\n\n[1] -12351.79"
  },
  {
    "objectID": "Projekty/LLM/index.html",
    "href": "Projekty/LLM/index.html",
    "title": "2. Model LLM",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Big Data"
  },
  {
    "objectID": "Projekty/MLR/index.html",
    "href": "Projekty/MLR/index.html",
    "title": "5. Function Factory",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\n\nOpis projektu\nZadanie polega na napisaniu funkcji createFitter(), która przyjmuje tylko jeden argument size. Zadaniem funkcji jest stworzenie nowej funkcji, tzw. fittera, która zawiera prostą sięć neuronową MLP o jednej warstwie ukrytej o wielkości size. Funkcja ta powinna przyjmować dwa argumenty: data, który jest ramką danych (alternatywnie obiektem dziedziczącym z data.frame, np. tbl_df) oraz formula, który jest formuła opisującą co w podanej ramce danych jest targetem a co features. Przykładowo, jeżeli w ramace danych mamy zmienne (kolumny) x i y to formuła y ~ x oznacza, że sieć na podstawie zmiennej x prognozuje zmienną y. Oczywiście powinny być wspierane skróty, np. y ~ . oznacza, że zmienna y jest prognozowana na podstawie wszystkich pozostałych w ramce danych zmiennych. Zadaniem fittera jest zdefiniowane nowej kolejnej funkcji, która jest predyktorem a więc funkcją, która dla podanych zmiennych zwraca predykcje. Tak więc fitter na podstawie podanej próby trenuje sieć neuronową i zwraca funkcję, predyktor, która zawiera wytrenowaną sieć neuronową i jej zadaniem jest tworzenie predykcji z wykorzystaniem wytrenowanej sieci neuronowej.\n\n\nMoje rozwiązanie\n\nlibrary(dplyr)\n\ncreateFitter &lt;- function(size) {\n  #createFitter upewnia się, że mamy właściwe biblioteki oraz tworzy kolejną funkcję\n  if(!require(nnet)){\n    install.packages(\"nnet\")\n    library(nnet)\n  } else {\n    library(nnet)\n  }\n  # Funkcja createFitter zwraca kolejną funckję \"fitter\"\n  return(function(data, formula){ \n    # Funkcja fitter tworzy sieć neuronową w ramach biblioteki nnet oraz tworzy definicję funkcji lines dla klasy data.frame. \n    # fitter\n    nn &lt;- nnet(formula, data, size = c(size), maxit=1000, rang = 0.1, decay = 5e-4, linout=T)\n    ## definicja f. lines dla klasy data.frame\n    e &lt;- parent.env(environment())\n    e$lines &lt;- function(x, ...) {\n      graphics::lines(x = x[,1], y = x[,2], ...)\n    }\n    \n    return(function(newData){\n      #Funkcja predyktor\n      #Zwraca dataframe ktory ma dwie kolumny, x ze zbioru wartości, których model wcześniej nie widział i y wyliczone na podstawie sieci neuronowej\n      out &lt;- data.frame(newData[,1], predict(nn, newData))\n      return(out)\n    })\n  })\n}\n\n\n\nPrzykłady\n\nPrzykład 1\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzenie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 10)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 1\n\n\n\n\n\n\nPrzykład 2\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 3)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 2\n\n\n\n\n\n\nPrzyklad 3\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd1 &lt;- tibble(\n  x = rnorm(10^3, mean = -5),\n  y = (x + 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd2 &lt;- tibble(\n  x = rnorm(10^3, mean = 5),\n  y = (x - 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd &lt;- rbind(d1, d2)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter3 &lt;- createFitter(size = 3)\nfitter20 &lt;- createFitter(size = 20)\n\n### Tworzenie predyktora. \npredictor3 &lt;- fitter3(formula = y ~ x, data = d)\npredictor20 &lt;- fitter20(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n#| label: przyklad-3\n#| fig-cap: \"Przykład 3\"\n#| warning: false\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\nlines(x = predictor3(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\nlines(x = predictor20(newData = dTest),\n      col = rgb(0, .5, 1, .9),\n      lwd = 2)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Igor Domaradzki",
    "section": "",
    "text": "Cześć! Witam na mojej stronie, na której znajdziecie moje portforlio Data Science.\nJestem studentem SGH na kierunku magisterskim Analiza danych - big data.\nWcześniej ukończyłem tam licencjat na kierunku Metody ilościowe w ekonomii i systemy informacyjne, gdzie napisałem pracę licencjacką “Zastosowanie teorii gier do analizy wybranych zagadnień w sporcie”\nMoje CV\nPoniżej kilka projektów, które stworzyłem.\n\n\n\nTo ja!\n\n\nStrona stworzona z użyciem RPosit Quarto i opublikowana dzięki Github Pages.\n\n\n\n\n\n\n\n\n\n\n\n\n\nR Wrapped\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel LLM\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorytm genetyczny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR6Class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction Factory\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCałki podwójne\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:::\n\nNo matching items\n\n:::\n:::"
  }
]