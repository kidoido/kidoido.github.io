[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Projekty/RWrapped/index.html",
    "href": "Projekty/RWrapped/index.html",
    "title": "R Wrapped",
    "section": "",
    "text": "Projekt wykonany na zajęcia Prezentacja i wizualizacja danych\nZa pomocą języka R przygotowałęm i zwizualizowałem swoje nawyki słuchania muzyki na plaformie Spotify\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n#remotes::install_github(\"ppatrzyk/lastfmR\")\nlibrary(lastfmR)\n\nLoading required package: curl\n\n\nUsing libcurl 8.4.0 with LibreSSL/3.3.6\n\n\nLoading required package: data.table\n\n\n\nAttaching package: 'data.table'\n\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\n\nLoading required package: xml2\nscrobbles &lt;- get_scrobbles(user = \"c00lll\", timezone = 'Europe/Warsaw')\nhead(scrobbles,10)\n\n                   date    artist\n               &lt;POSIXt&gt;    &lt;char&gt;\n 1: 2024-08-01 16:32:31 JPEGMAFIA\n 2: 2024-08-01 16:30:29 JPEGMAFIA\n 3: 2024-08-01 16:27:02 JPEGMAFIA\n 4: 2024-08-01 16:22:10 JPEGMAFIA\n 5: 2024-08-01 16:19:56 JPEGMAFIA\n 6: 2024-08-01 16:14:55 JPEGMAFIA\n 7: 2024-08-01 16:04:44 JPEGMAFIA\n 8: 2024-08-01 16:01:52 JPEGMAFIA\n 9: 2024-08-01 15:59:35 JPEGMAFIA\n10: 2024-08-01 15:57:05 JPEGMAFIA\n                                                track\n                                               &lt;char&gt;\n 1: Don't Put Anything On the Bible (feat. Buzzy Lee)\n 2:                              loop it and leave it\n 3:                        either on or off the drugs\n 4:                   JPEGULTRA! (feat. Denzel Curry)\n 5:                                         JIHAD JOE\n 6:                                        Exmilitary\n 7:                           vulgar display of power\n 8:                           don't rely on other men\n 9:           New Black History (feat. Vince Staples)\n10:                         it's dark and hell is hot\n                         album\n                        &lt;char&gt;\n 1: I LAY DOWN MY LIFE FOR YOU\n 2: I LAY DOWN MY LIFE FOR YOU\n 3: I LAY DOWN MY LIFE FOR YOU\n 4: I LAY DOWN MY LIFE FOR YOU\n 5: I LAY DOWN MY LIFE FOR YOU\n 6: I LAY DOWN MY LIFE FOR YOU\n 7: I LAY DOWN MY LIFE FOR YOU\n 8: I LAY DOWN MY LIFE FOR YOU\n 9: I LAY DOWN MY LIFE FOR YOU\n10: I LAY DOWN MY LIFE FOR YOU\nscrobbles &lt;- scrobbles[(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles &lt;- scrobbles[rev(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles &lt;- scrobbles[(order(as.Date(scrobbles$date, format=\"%Y-%m-%d %H:%M:%S\"))),]\nscrobbles$jedynki &lt;- 1\nscrobbles$cum_sum &lt;- ave(scrobbles$jedynki, scrobbles$track, FUN=cumsum)\nscrobbles$cum_sum_artists &lt;- ave(scrobbles$jedynki, scrobbles$artist, FUN=cumsum)\nscrobbles$cum_sum_albums &lt;- ave(scrobbles$jedynki, scrobbles$album, FUN=cumsum)\nhead(scrobbles,10)\n\n                   date       artist  track         album jedynki cum_sum\n               &lt;POSIXt&gt;       &lt;char&gt; &lt;char&gt;        &lt;char&gt;   &lt;num&gt;   &lt;num&gt;\n 1: 2018-06-18 14:46:17 BROCKHAMPTON  JUNKY SATURATION II       1       1\n 2: 2018-06-18 14:51:57 BROCKHAMPTON   BANK    SATURATION       1       1\n 3: 2018-06-18 14:55:13 BROCKHAMPTON   TRIP    SATURATION       1       1\n 4: 2018-06-18 14:58:37 BROCKHAMPTON   STAR    SATURATION       1       1\n 5: 2018-06-18 15:01:18 BROCKHAMPTON   FAKE    SATURATION       1       1\n 6: 2018-06-18 22:47:18 BROCKHAMPTON   BANK    SATURATION       1       2\n 7: 2018-06-18 22:50:51 BROCKHAMPTON   TRIP    SATURATION       1       2\n 8: 2018-06-18 22:54:30 BROCKHAMPTON   STAR    SATURATION       1       2\n 9: 2018-06-18 22:56:05 BROCKHAMPTON   DIRT          Dirt       1       1\n10: 2018-06-19 00:00:01 BROCKHAMPTON   DIRT          Dirt       1       2\n    cum_sum_artists cum_sum_albums\n              &lt;num&gt;          &lt;num&gt;\n 1:               1              1\n 2:               2              1\n 3:               3              2\n 4:               4              3\n 5:               5              4\n 6:               6              5\n 7:               7              6\n 8:               8              7\n 9:               9              1\n10:              10              2\n#sortoowanie tabeli pod względem piosenek\ncount_whole &lt;- table(scrobbles$track)\ncount_whole_sorted &lt;- sort(count_whole, decreasing = T)\n#Top 10 piosenek\nxy &lt;- head(count_whole_sorted, 10)\n\n#wydruk w konsoli top 10 piosenek\nfor (i in 1:10) {\n  cat(paste0(i, \". \", scrobbles[track == names(xy[i])]$artist[2], \" - \", names(xy[i]),\": \", as.numeric(xy[i]), \"\\n\"))\n}\n\n1. 100 gecs - money machine: 239\n2. Meek, Oh Why? - Pieśniarka i Król: 203\n3. JPEGMAFIA - 1539 N. Calvert: 202\n4. 100 gecs - hand crushed by a mallet: 183\n5. Coals - Blue (feat. Schafter): 166\n6. 100 gecs - ringtone: 157\n7. 100 gecs - sympathy 4 the grinch: 148\n8. laura les - Haunted: 147\n9. ericdoa - movinglikeazombie - remix: 145\n10. QUEEF JERKY - PINEAPPLE UPSIDE DOWN: 143\n\nfor (i in 1:10) {\n  names(xy)[i] &lt;- paste0(scrobbles[track == names(xy[i])]$artist[2], \" - \", names(xy[i]))\n}"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#listy-top-10",
    "href": "Projekty/RWrapped/index.html#listy-top-10",
    "title": "R Wrapped",
    "section": "Listy Top 10",
    "text": "Listy Top 10\n\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#050861\", \"#131ad6\"))\nvalues_barplot &lt;- as.numeric(rev(xy))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(xy), horiz = T, las = 1, yaxt = \"n\", xlim=c(0, 250), col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 utworów wszechczasów\")\ntext(as.numeric(rev(xy)), barplot_tracks, labels = as.numeric(rev(xy)), pos = 2, col = \"white\", cex = 3/4, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(xy))), pos = 4, col = \"white\", cex = 0.75, font = 2)\n\n\n\n\n\n\n\n\n\ncount_artist &lt;- table(scrobbles$artist)\nartist_sorted &lt;- sort(count_artist, decreasing = T)\n#Top 10 artystów\nzt &lt;- head(artist_sorted,10)\nfor (i in 1:10) {\n  cat(i, \". \", names(zt[i]),\": \", as.numeric(zt[i]), \"\\n\", sep = \"\")\n}\n\n1. Taco Hemingway: 2764\n2. 100 gecs: 2417\n3. Holak: 2111\n4. JPEGMAFIA: 2089\n5. Meek, Oh Why?: 1872\n6. Charli XCX: 1871\n7. BROCKHAMPTON: 1692\n8. Kendrick Lamar: 1293\n9. TV Girl: 1252\n10. ROSALÍA: 1018\n\n\n\n#plot Top 10 artystow \npar(mar=c(5,2,2,2))\nzt &lt;- head(artist_sorted,10)\npal &lt;- colorRamp(c(\"#4f1403\", \"#992c0e\"))\nvalues_barplot &lt;- as.numeric(rev(zt))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(zt), horiz = T, las = 1, yaxt = \"n\", col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 artystów wszechczasów\")\ntext(as.numeric(rev(zt)), barplot_tracks, labels = as.numeric(rev(zt)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(zt))), pos = 4, col = \"white\", cex = 0.8, font = 2)\n\n\n\n\n\n\n\n\n\ncount_album &lt;- table(scrobbles$album)\nalbums_sorted &lt;- sort(count_album, decreasing = T)\n#Top 10 albumów\nzz &lt;- head(albums_sorted,10)\nfor (i in 1:10) {\n  cat(i, \". \", scrobbles[album == names(zz[i])]$artist[2], \" - \", names(zz[i]),\": \", as.numeric(zz[i]), \"\\n\",sep = \"\")\n}\n\n1. Meek, Oh Why? - Zachód: 1100\n2. 100 gecs - 1000 gecs: 853\n3. Travis Scott - ASTROWORLD: 652\n4. BROCKHAMPTON - GINGER: 612\n5. 100 gecs - 1000 gecs and The Tree of Clues: 606\n6. Taco Hemingway - Café Belga: 571\n7. Taco Hemingway - Pocztówka z WWA, lato '19: 556\n8. Phoebe Bridgers - Punisher: 545\n9. Blood Orange - Negro Swan: 541\n10. JPEGMAFIA - Veteran: 537\n\nfor (i in 1:10) {\n  names(zz)[i] &lt;- paste0(scrobbles[album == names(zz[i])]$artist[2], \" - \", names(zz[i]))\n}\n\n\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#004f1c\", \"#0fa343\"))\nvalues_barplot &lt;- as.numeric(rev(zz))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(zz), horiz = T, las = 1, yaxt = \"n\", col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Top 10 albumów wszechczasów\")\ntext(as.numeric(rev(zz)), barplot_tracks, labels = as.numeric(rev(zz)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(zz))), pos = 4, col = \"white\", cex = 0.7, font = 2)"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#wyścigi-utworów",
    "href": "Projekty/RWrapped/index.html#wyścigi-utworów",
    "title": "R Wrapped",
    "section": "Wyścigi utworów",
    "text": "Wyścigi utworów\n\n#############\n#Wyścig utworów\nxxx &lt;- scrobbles[track == names(count_whole_sorted[1]),]\n\nplot(xxx$date, xxx$cum_sum, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Czas odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń utworów\")\n\nfor (track_name in names(count_whole_sorted)) {\n  to_drow &lt;- scrobbles[track == track_name,]\n  lines(to_drow$date, to_drow$cum_sum, type = \"s\", col = \"#dbd7ca\")\n}\n\nlines(xxx$date, xxx$cum_sum, type = \"s\", col = \"gold\", lwd=3)\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_drow &lt;- scrobbles[track == names(count_whole_sorted[i]),]\n  lines(to_drow$date, to_drow$cum_sum, type = \"s\", col = \"black\")\n}\n\nxxx3 &lt;- scrobbles[track == names(count_whole_sorted[3]),]\nlines(xxx3$date, xxx3$cum_sum, type = \"s\", col = \"brown\", lwd = 3)\n\nxxx2 &lt;- scrobbles[track == names(count_whole_sorted[2]),]\nlines(xxx2$date, xxx2$cum_sum, type = \"s\", col = \"grey\", lwd = 3)\n\nlines(xxx$date, xxx$cum_sum, type = \"s\", col = \"gold\", lwd=3)\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum), c(names(count_whole_sorted[1]), names(count_whole_sorted[2]), names(count_whole_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.6, title=\"Nazwy utworów\", text.font=1) \n\n\n\n\n\n\n\n\n\n#############\n#Wyścig artystow\nyyy &lt;- scrobbles[artist == names(artist_sorted[1]),]\n\nplot(yyy$date, yyy$cum_sum_artists, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Czas odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń artystow\")\n\n\nfor (artist_name in names(artist_sorted)) {\n  to_drow &lt;- scrobbles[artist == artist_name,]\n  lines(to_drow$date, to_drow$cum_sum_artists, type = \"s\", col = \"#dbd7ca\")\n}\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_drow &lt;- scrobbles[artist == names(artist_sorted[i]),]\n  lines(to_drow$date, to_drow$cum_sum_artists, type = \"s\", col = \"black\")\n}\n\nyyy3 &lt;- scrobbles[artist  == names(artist_sorted[3]),]\nlines(yyy3$date, yyy3$cum_sum_artists, type = \"s\", col = \"brown\", lwd = 3)\n\nyyy2 &lt;- scrobbles[artist  == names(artist_sorted[2]),]\n\nlines(yyy2$date, yyy2$cum_sum_artists, type = \"s\", col = \"grey\", lwd = 3)\nlines(yyy$date, yyy$cum_sum_artists, type = \"s\", col = \"gold\", lwd=3)\n\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum_artists), c(names(artist_sorted[1]), names(artist_sorted[2]), names(artist_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.6, title=\"Nazwy artystów\", text.font=1) \n\n\n\n\n\n\n\n\n\n#####\n#Wyścig  albumów\nyyy &lt;- scrobbles[album == names(albums_sorted[1]),]\n\nplot(yyy$date, yyy$cum_sum_albums, type = \"s\", col = \"gold\", lwd=3, xlim = c(min(scrobbles$date), max(scrobbles$date)), xlab = \"Moment odsłuchu\", ylab = \"Ilość odtworzeń\", main = \"Wykres sumy odtworzeń albumów\")\n\nfor (album_name in names(albums_sorted)) {\n  to_drow &lt;- scrobbles[album == album_name,]\n  lines(to_drow$date, to_drow$cum_sum_albums, type = \"s\", col = \"#dbd7ca\")\n}\n\n\nmy_range &lt;- 4:10\nfor (i in my_range) {\n  to_drow &lt;- scrobbles[album == names(albums_sorted[i]),]\n  lines(to_drow$date, to_drow$cum_sum_albums, type = \"s\", col = \"black\")\n}\n\n\nyyy3 &lt;- scrobbles[album  == names(albums_sorted[3]),]\nlines(yyy3$date, yyy3$cum_sum_albums, type = \"s\", col = \"brown\", lwd = 3)\n\nyyy2 &lt;- scrobbles[album  == names(albums_sorted[2]),]\nlines(yyy2$date, yyy2$cum_sum_albums, type = \"s\", col = \"grey\", lwd = 3)\n\nlines(yyy$date, yyy$cum_sum_albums, type = \"s\", col = \"gold\", lwd=3)\n\n\nlegend(min(scrobbles$date), max(scrobbles$cum_sum_albums), c(names(albums_sorted[1]), names(albums_sorted[2]), names(albums_sorted[3])), col=c(\"gold\", \"grey\", \"brown\"),lty = 1, cex=0.7, title=\"Nazwy albumów\", text.font=1)"
  },
  {
    "objectID": "Projekty/RWrapped/index.html#ggplot",
    "href": "Projekty/RWrapped/index.html#ggplot",
    "title": "R Wrapped",
    "section": "Ggplot",
    "text": "Ggplot\n\nlibrary(ggplot2)\nlibrary(dplyr)\n\nscrobbles_copy &lt;- scrobbles\n\nxx &lt;- (scrobbles_copy  %&gt;% \n         group_by(month = lubridate::floor_date(date, 'month')) %&gt;%\n         summarize(l_wystapien = sum(jedynki)))\n\nxx$month_name &lt;- month(xx$month)\nxx$year  &lt;- year(xx$month)\n\n# Heatmap \nggplot(xx, aes(year, month_name)) + \n  geom_tile(aes(fill= l_wystapien), col = \"white\") +\n  scale_fill_gradient(low = \"#fac8d8\", high = \"#87002b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań danego miesiąca\") +\n  scale_y_reverse() + scale_x_discrete(limits=2018:2024)+\n  xlab(\"Rok\") + ylab(\"Miesiąc\")\n\n\n\n\n\n\n\n#heatmap z wartosciami\nggplot(xx, aes(year, month_name)) + \n  geom_tile(aes(fill= l_wystapien), col = \"white\") +\n  scale_fill_gradient(low = \"#fac8d8\", high = \"#87002b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań danego miesiąca\") +\n  scale_x_discrete(limits=2018:2024)+\n  xlab(\"Rok\") + ylab(\"Miesiąc\") + \n  geom_text(aes(label = l_wystapien), col = \"white\", cex = 4.5) +\n  scale_y_reverse()\n\n\n\n\n\n\n\n\n\n#Średnia Liczba odtworzeń na miesiąc\nsrednie_wartosci &lt;- xx %&gt;%\n  group_by(month_name) %&gt;%\n  summarise(SredniaWartosc = mean(l_wystapien))\n\nsrednie_wartosci &lt;- setNames(srednie_wartosci, c(\"Miesiąc\", \"Średnia Liczba odtworzeń na miesiąc\"))\nsrednie_wartosci$Miesiąc &lt;- factor(month.name[srednie_wartosci$Miesiąc], levels = month.name)\n\n\npar(mar=c(5,6,3,3))\npal &lt;- colorRamp(c(\"#37420D\", \"#9CBD26\"))\nvalues_barplot &lt;- as.numeric(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_mies &lt;- barplot(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`), names = rev(srednie_wartosci$Miesiąc), las = 1, xlim=c(0,1300), horiz = T, col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Średnia liczba odtworzeń w miesiącu\")\ntext(60, barplot_mies, labels = round(rev(srednie_wartosci$`Średnia Liczba odtworzeń na miesiąc`)), col = \"white\", font = 2, cex = 0.9)\n\n\n\n\n\n\n\n\n\nby_year &lt;- aggregate(l_wystapien ~ year, data=xx, sum)\nby_year &lt;- setNames(by_year, c(\"Rok\", \"Liczba odtworzeń\"))\n\nbarplot_przed_usr &lt;- barplot(by_year[,2], names = by_year[,1], ylim = c(0,18000), main = \"Liczba odtworzen w ciągu roku\", col = \"#aa5555\")\ntext(barplot_przed_usr, by_year[,2] + 650, labels = by_year[,2])\n\n\n\n\n\n\n\n#Srednia odtworzen na miesiąc podczas danego roku\nby_year$l_miesiecy &lt;-c(7,12,12,12,12,12,6)\nby_year$na_mies &lt;- by_year$`Liczba odtworzeń` / by_year$l_miesiecy\nby_year$na_mies &lt;- round(by_year$na_mies,0)\n#t(by_year)\npokaz_by_year &lt;- t(by_year[c(1,4)])\n#pokaz_by_year\nbarplot_lata &lt;- barplot(pokaz_by_year[2,], names = pokaz_by_year[1,], col = \"#aa5555\", ylim=c(0,1500), main = \"Średnia liczba odtworzeń na miesiąc\")\ntext(barplot_lata, pokaz_by_year[2,] + 50, labels = pokaz_by_year[2,])\n\n\n\n\n\n\n\n\n\nlibrary(lubridate)\n#heat map dzien/godzina\nday_plot &lt;- (scrobbles_copy  %&gt;% \n         group_by(date = lubridate::floor_date(date, 'hour')) %&gt;%\n         summarize(l_wystapien = sum(jedynki)))\n\n#day_plot$day &lt;- wday(day_plot$date, week_start = getOption(\"lubridate.week.start\", 1))\n\nday_plot$day &lt;- wday(day_plot$date - days(1))\nday_plot$hour  &lt;- hour(day_plot$date)\n\nday_plot_to_draw &lt;- day_plot %&gt;%\n  group_by(day, hour) %&gt;%\n  summarise(Suma = sum(l_wystapien))\n\n`summarise()` has grouped output by 'day'. You can override using the `.groups`\nargument.\n\n# Heatmap \ng &lt;- ggplot(day_plot_to_draw, aes(day, hour)) + \n  geom_tile(aes(fill= Suma), col = \"white\") +\n  scale_fill_gradient(low = \"#fad8e8\", high = \"#67000b\", name = \"Odtworzenia\") +\n  ggtitle(\"Liczba odsłuchań o danej pory dnia\")  + scale_x_discrete(limits=1:7, labels = c(\"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\", \"Niedziela\")) +\n  scale_y_discrete(limits=0:23) + xlab(\"Godzina\") + ylab(\"Dzień\")\ng\n\n\n\n\n\n\n\n#dodanie wartości na mapę\ng + geom_text(aes(label = Suma), col = \"white\", cex = 3)\n\n\n\n\n\n\n\n# dzien i godzina z najwieksza iloscia odsłuchań\nday_plot_to_draw[which.max(day_plot_to_draw$Suma),]\n\n# A tibble: 1 × 3\n# Groups:   day [1]\n    day  hour  Suma\n  &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n1     2    17   935\n\n\n\nartist_info &lt;- get_library_info(user = \"c00lll\")\n\n\nlibrary(stringr)\nlibrary(wordcloud)\n\nLoading required package: RColorBrewer\n\n#wordcloud\n\nartist_info$genres &lt;- str_split(artist_info$artist_tags, \"; \")\ngenres_unlisted &lt;- unlist(artist_info$genres)\n\n# Utworzenie tabeli częstości gatunków\ntabela_czestosci_gatunkow &lt;- table(genres_unlisted)\nlista_nazw_gat &lt;- names(tabela_czestosci_gatunkow)\n\n#chmura słów\npar(mar=c(2,2,2,2))\nwordcloud(lista_nazw_gat, as.numeric(tabela_czestosci_gatunkow), colors = c(\"#101112\", \"#384a8c\", \"#db8904\"))\n\n\n\n\n\n\n\n\n\nnajczestszy_gatunek &lt;- names(tabela_czestosci_gatunkow)[which.max(tabela_czestosci_gatunkow)]\n\ntest_cgest &lt;- rev(sort(tabela_czestosci_gatunkow, deacreasing = T))\ntest_cgest[1]\n\nelectronic \n       502 \n\n# Lista najczęstszych gatunków wśrod artystów\nfor (i in 1:10){\n  print(paste0(i, \". \", names(test_cgest[i]), \": \", as.numeric(test_cgest[i])))\n}\n\n[1] \"1. electronic: 502\"\n[1] \"2. Hip-Hop: 431\"\n[1] \"3. rap: 391\"\n[1] \"4. seen live: 384\"\n[1] \"5. pop: 341\"\n[1] \"6. indie: 331\"\n[1] \"7. hip hop: 210\"\n[1] \"8. indie pop: 177\"\n[1] \"9. experimental: 161\"\n[1] \"10. female vocalists: 160\"\n\ntc &lt;- head(test_cgest,10)\npar(mar=c(5,2,2,2))\npal &lt;- colorRamp(c(\"#050861\", \"#131ad6\"))\nvalues_barplot &lt;- as.numeric(rev(tc))\nkolor_barplot &lt;- rgb(pal((values_barplot - min(values_barplot))/ diff(range(values_barplot))), max=255)\nbarplot_tracks &lt;- barplot(rev(tc), horiz = T, las = 1, yaxt = \"n\", xlim=c(0, 450), col = kolor_barplot, xlab = \"Ilość odtworzeń\", main = \"Najczęstrze tagi wśród artystów\")\ntext(as.numeric(rev(tc)), barplot_tracks, labels = as.numeric(rev(tc)), pos = 2, col = \"white\", cex = 0.8, font = 2)\ntext(1, barplot_tracks, labels = paste0(rev(names(tc))), pos = 4, col = \"white\", cex = 0.8, font = 2)\n\n\n\n\n\n\n\n\n\n### najpopularniejsci artysci dla kazdego miesiaca\nn_months &lt;- 1 + interval(mdy(06012018), today()) %/% months(1)\nmacierz &lt;- matrix(NA, 12, 7)\nmacierz_to_plot &lt;- matrix(NA, n_months, 2)\ndate_temp &lt;- min(scrobbles_copy$date)\ndate_temp &lt;- floor_date(date_temp, 'month')\ndate_temp_next &lt;- date_temp %m+% months(1)\npier_mies = 6\nfor (i in 1:73) {\n  month_in_scr &lt;- scrobbles[scrobbles$date &gt; date_temp & scrobbles$date &lt; date_temp_next]\n  t_month_in_scr &lt;- table(month_in_scr$artist)\n  t_month_in_scr &lt;- sort(t_month_in_scr, decreasing = T)\n  naj_artysta &lt;- names(t_month_in_scr[1])\n  ich_odtworzenia_wtedy &lt;- as.numeric(t_month_in_scr[1])\n  date_temp_next &lt;- date_temp_next %m+% months(1)\n  date_temp &lt;- date_temp %m+% months(1)\n  macierz[pier_mies] = naj_artysta\n  macierz_to_plot[pier_mies-5, 1] = substr(naj_artysta,1,26)\n  macierz_to_plot[pier_mies-5, 2] = ich_odtworzenia_wtedy\n  pier_mies &lt;- pier_mies + 1\n}\n#macierz\n#macierz_to_plot\ncolnames(macierz) &lt;- c(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\", '2023', '2024')\nrownames(macierz) &lt;- c(\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\")\n\ndf_barplot &lt;- as.data.frame(macierz_to_plot)\n\n\ndf_barplot$month_name &lt;- xx$month_name\ndf_barplot$year &lt;- xx$year\n\nnames(df_barplot)[1:2] &lt;- c(\"Artysta\", \"Wystapienia_w_mies\")\n\ntibble_barplot &lt;- as_tibble(df_barplot)\ntibble_barplot$Wystapienia_w_mies &lt;- as.double(tibble_barplot$Wystapienia_w_mies)\n\ng &lt;- ggplot(tibble_barplot, aes(year, as.numeric(month_name))) + \n  geom_tile(aes(fill= as.double(Wystapienia_w_mies)), col = \"white\") +\n  scale_fill_gradient(low = \"#e5ced4\", high = \"#451350\", name = \"Odtworzenia \\n w miesiącu\") +\n  ggtitle(\"Liczba odsłuchań najczęściej słuchanego artysty danego miesiąca\") +\n  scale_x_discrete(limits=2018:2024)+\n  xlab(\"Rok\") + ylab(\"Miesiąc\") +\n  scale_y_reverse() +\n  geom_text(aes(label = substr(Artysta, 1, 14)), col = \"white\", size = 1.7, font = 2)\ng"
  },
  {
    "objectID": "Projekty/R6Class/index.html",
    "href": "Projekty/R6Class/index.html",
    "title": "R6Class",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\nOpis projektu\nProjekt dotyczy rozszerzonej reprezentacji szeregu czasowego. W języku R jest wiele możliwości reprezentowania szeregów czasowych. Podstawowe klasy to ts i mts. Klasy, które rozszerzają te klasy to zoo i xts. Wszystkie te klasy reprezentują jedynie dane a więc dane dotyczące czasu i wartości. W tym projekcie chcemy do danych dołożyć operacje, które są wykonywane na szeregach czasowych oraz metody, które tworzą prognozy.\nTechnicznie, zadaniem w projekcie jest zdefiniowanie klasy timeSeries w modelu obiektowym R6, która na podstawie wektora określającego czas i wektora wartości, inicjalizuje instancję klasy. Metoda new powinna przyjmować dwa argumenty: times, który przyjmuje wektor czasów (i tutaj możemy wykorzystać dowolną klasę reprezentującą datę i czas, np. Date czy yearmon) oraz values, który przyjmuje wektor wartości.\nKlasa musi oferować następujące podstawowe metody.\n\nMetoda getTimes, która zwraca podany wektor czasów.\nMetoda getValues, która zwraca podany wektor wartości.\nMetoda getTimeSeries, która zwraca szereg czasowy. W rozwiązaniu proszę wykorzystać klasę xts.\n\nProjekt jest zatem rozszerzeniem klasy xts.\nPowyższe metody są typowymi fundamentalnymi metodami związanymi z szeregiem czasowym.\n\n\nMoja definicja funkcji\n\nlibrary(R6)\nlibrary(xts)\nlibrary(zoo)\nlibrary(tibble)\nlibrary(ggplot2)\n\ntimeSeries &lt;- R6Class(\n  classname = \"timeSeries\",\n  public = list(\n    times = NA,\n    values = NA,\n    table = NULL,\n    operations = list(),\n    models = list(),\n    paths = list(),\n    initialize = function(times, values) {\n      self$times &lt;- times\n      self$values &lt;- values\n      self$table &lt;- xts::xts(x = self$values, order.by = self$times)\n    },\n    \n    getTimes = function() {\n      self$times\n    },\n    \n    getValues = function() {\n      self$values\n    },\n    \n    getTimeSeries = function() {\n      self$table\n    },\n    \n    opsAppend = function(...) {\n      ops &lt;- list(...)\n      for (name in names(ops)) {\n        self$operations[[name]] &lt;- ops[[name]]\n      }\n    },\n    \n    opsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$operations[[key]] &lt;- NULL\n      }\n    },\n    \n    opsList = function() {\n      data.frame(id = seq_along(self$operations), name = names(self$operations))\n    },\n    modelsAppend = function(...){\n      model &lt;- list(...)\n      for (name in names(model)) {\n        self$models[[name]] &lt;- model[[name]]\n      }\n    },\n    modelsRemove = function(...) {\n      keys &lt;- list(...)\n      for (key in keys) {\n        self$models[[key]] &lt;- NULL\n      }\n    },\n    modelsList = function() {\n      data.frame(id = seq_along(self$models), name = names(self$models))\n    },\n    pathsAppend = function(pathName, operations, model){\n      self$paths[[pathName]] &lt;- list(operations = operations, model = model)\n      },\n    pathsRemove = function(...) {\n      pathNames &lt;- list(...)\n      for (pathName in pathNames) {\n        self$paths[[pathName]] &lt;- NULL\n      }\n    },\n    pathsList = function() {\n      paths_df &lt;- do.call(rbind, lapply(names(self$paths), function(name) {\n        data.frame(\n          id = which(names(self$paths) == name),\n          name = name,\n          operations = paste(self$paths[[name]]$operations, collapse = \" → \"),\n          model = self$paths[[name]]$model,\n          stringsAsFactors = FALSE\n        )\n      }))\n      paths_df\n    },\n    pathsRun = function(pathName) {\n      if (!(pathName %in% names(self$paths))) {\n        stop(\"Path not found.\")\n      }\n      path &lt;- self$paths[[pathName]]\n      result &lt;- self$table\n      for (op in path$operations) {\n        result &lt;- self$operations[[op]](result)\n      }\n      prediction &lt;- self$models[[path$model]](result)\n      prediction\n    }\n    \n  )\n)\n\n\n\nPrzykłady\n\nPrzykład 1\nPoniższy przykład tworzy bardzo prosty szereg czasowy i pokazuje działanie opisanych powyżej metod.\nPrzykład pokazuje inicjalizację obiektu klasy timeSeries oraz wykorzytanie podstawowych metod. Na tej podstawie tworzony jest prosty wykres szeregu czasowego.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Pobranie wartości\ny$getValues()\n\n [1] -0.1945931  2.0296125  2.2494422  2.3306086  0.2738885  0.2727160\n [7]  0.5927481  1.1976653  1.0515682  2.5435219  4.0328960  4.9284891\n[13]  3.5270323  2.8071987  3.1246487  4.0986541  4.5148205  5.4911681\n[19]  5.2639328  5.4393477  6.8309748  6.5403368  6.2650100  8.0704784\n[25]  8.8069602  9.1106219  8.9457140  7.8518689  6.6290026  5.2143623\n[31]  3.8095895  4.6611919  3.9195684  3.4193467  4.3919769  5.3984667\n[37]  3.9861762  4.5258649  6.0396298  6.5530355  6.6316530  7.7803607\n[43]  8.6175383  8.6890580  8.1515914  9.0604987  9.7969240  8.6574288\n[49]  8.5837164  9.2724559  8.9914589  9.3938058 10.4532908 10.4026083\n[55] 11.3406738  9.7907741  9.8533625 10.4075872 10.4813460 10.5109694\n\n### Pobranie wektora czasów\ny$getTimes()\n\n [1] \"Jan 2009\" \"Feb 2009\" \"Mar 2009\" \"Apr 2009\" \"May 2009\" \"Jun 2009\"\n [7] \"Jul 2009\" \"Aug 2009\" \"Sep 2009\" \"Oct 2009\" \"Nov 2009\" \"Dec 2009\"\n[13] \"Jan 2010\" \"Feb 2010\" \"Mar 2010\" \"Apr 2010\" \"May 2010\" \"Jun 2010\"\n[19] \"Jul 2010\" \"Aug 2010\" \"Sep 2010\" \"Oct 2010\" \"Nov 2010\" \"Dec 2010\"\n[25] \"Jan 2011\" \"Feb 2011\" \"Mar 2011\" \"Apr 2011\" \"May 2011\" \"Jun 2011\"\n[31] \"Jul 2011\" \"Aug 2011\" \"Sep 2011\" \"Oct 2011\" \"Nov 2011\" \"Dec 2011\"\n[37] \"Jan 2012\" \"Feb 2012\" \"Mar 2012\" \"Apr 2012\" \"May 2012\" \"Jun 2012\"\n[43] \"Jul 2012\" \"Aug 2012\" \"Sep 2012\" \"Oct 2012\" \"Nov 2012\" \"Dec 2012\"\n[49] \"Jan 2013\" \"Feb 2013\" \"Mar 2013\" \"Apr 2013\" \"May 2013\" \"Jun 2013\"\n[55] \"Jul 2013\" \"Aug 2013\" \"Sep 2013\" \"Oct 2013\" \"Nov 2013\" \"Dec 2013\"\n\n### Pobranie szeregu czasowgo (klasa xts)\nhead(y$getTimeSeries(),10)\n\n               [,1]\nJan 2009 -0.1945931\nFeb 2009  2.0296125\nMar 2009  2.2494422\nApr 2009  2.3306086\nMay 2009  0.2738885\nJun 2009  0.2727160\nJul 2009  0.5927481\nAug 2009  1.1976653\nSep 2009  1.0515682\nOct 2009  2.5435219\n\n### Stworzenie przykładowego wykresu\nggplot(\n  data = tibble(time = y$getTimes(), value = y$getValues()),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  labs(title = \"Example of a time series\") +\n  theme_light()\n\n\n\n\n\n\n\n\n\n\nPrzykład 2\nPodstawowe metody, opisane powyżej, nie wyczerpują operacji, które chcemy dodać do szeregu czasowego. Oczywiście katalog potencjalnych operacji nie jest skończony więc nie możemy dodać metod reprezentujących wszystkie potencjalne operacje. Z tego powodu chcemy mieć możliwość dodawania dowolnych operacji i następnie wiązania tych operacji. W pierwszej kolejności chcemy zbudować prosty system zarządzania operacjami. Na potrzeby tego projektu, operacja na szeregu czasowym, to dowolna funkcja, która jako argument przyjmuje szereg czasowy (klasa xts) i zwraca szereg czasowy (ponownie klasa xts). Tak więc musimy mieć następujące metody.\n\nMetoda opsAppend do dodawania operacji. Składania tej metody powinna być identyczna ze składnią funkcji list. Konieczne jest podanie kluczy jednoznacznie identyfikujących\nMetoda opsRemove do usuwania operacji. Metoda przyjmuje dowolną liczbę stringów, które są kluczami usuwanych operacji.\nMetoda opsList, która listuje operacje, które aktualnie są w liście dodanych operacji.\n\nPoniższy przykład pokazuje metody dodawania, listowania i usuwania operacji.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy operacje.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\n### Usuwanie operacji\ny$opsRemove(\"logs_abs\")\n\n### Listowanie operacji\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2      na_omit\n\n\n\n\nPrzykład 3\nKolejnym elementem, które musi się znaleźć w klasie jest model predykcji. Na potrzeby tego projektu, przez model predkcji będziemy rozumieli dowolną funkcję, która jako argument przyjmuje obiekt klasy xts i zwraca obiekt tej klasy. Ponownie, katalog możliwych modeli predykcji nie jest zamknięty, więc również musimy mieć prosty system zarządzania. W szczególności klasa musi oferować następujące metody.\n\nMetoda modelsAppend, która pozwala na dodawanie modeli. Składnia tej metody powinna być taka jak funkcji list. Podobnie jak poporzednio, konieczne jest podanie unikalnych kluczy indetyfikujących modele.\nMetoda modelsRemove, która pozwana na usunięcie modeli. Metoda musi przyjmować stringi, które definiują dodane modele.\nMetoda modelsList, która listuje dodane modele.\n\nPoniższy przykład pokazuje zastosowanie opisanych metod.\nW przykładzie tworzymy nowy obiekt, następnie dodajemy, listujemy i usuwamy modele.\n\n### Tworzenie danych do szeregu czasowego: \nts &lt;- yearmon(2009) + (0:(5 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 5 + cumsum(rnorm(5 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie prostego modelu liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identyczności\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listowanie modelu\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Usuwanie modelu\ny$modelsRemove(\"identity_prediction\")\n\n### Listowanie modelu\ny$modelsList()\n\n  id              name\n1  1 linear_prediciton\n\n\n\n\nPrzykład 4\nSame operacje oraz modele nic nie robią. Kolejne zadanie to wiązanie operatorów i kończenie ich modelami predykcji. Powiązanie takie ma postać szereg czasowy → operator 1 → operator 2 → … → operator n → model. Każde takie powiązanie nazywamy dalej ścieżką obliczeniową (path). Klasa musi mieć narzędzia do tworzenia i zarządzania takimi ścieżkami obliczeniowymi. Klasa musi oferować następujące metody.\n\nMetoda pathsAppend musi pozwalać dodawać ścieżki obliczeniowe. Metoda ta powinna przyjmować trzy argumenty. Argument pathName, który jest stringiem i jest unikalny. Argument operations, który jest wektorem stringów definiujących dodane operacje. Argument model, który jest stringiem definiującym model predykcji. Razem metoda pozwala definiować ścieżkę obliczeniową.\nMetoda pathsRemove musi pozwalać na usuwanie poprzednio zdefiniowanych ścieżek obliczeniowych. Metoda przyjmuje dowolną liczbę stringów definiujących ścieżki obliczeniowe.\nMetoda pathsList, która listuje zdefiniowane ścieżki.\nMetoda pathsRun, która przyjmuje argument pathName, który jest stringiem definiującym ścieżkę.\n\nMetoda ta wykonuje obliczenia dla zdefiniowanej ścieżki a więc w kolejności zdefiniowanej w ścieżce stosuje funkcje definiujące operacje i na końcu model obliczeniowy. Wynikiem jest więc prognoza dla szeregu czasowego.\n\nlibrary(dplyr)\ndetach(\"package:dplyr\", unload = TRUE)\n\n### Tworzenie danych do szeregu czasowego:\nts &lt;- yearmon(2009) + (0:(2 * 12 - 1)) / 12\nvs &lt;- seq_along(ts) / 10 + cumsum(rnorm(2 * 12))\n\n### Inicjalizacja obiektu\ny &lt;- timeSeries$new(times = ts, values = vs)\n\n### Dodawanie operacji na szeregu czasowycvh\ny$opsAppend(\n  differencing = function(x) { diff(x = x, lag = 1, differences = 1) },\n  logs_abs = function(x) { log(abs(x)) },\n  na_omit = na.omit\n)\n\n### Dodawanie prostego modeli liniowego\ny$modelsAppend(\n  linear_prediciton = function(x) {\n    dtemp &lt;- data.frame(\n      t = seq_along(coredata(x)),\n      z = coredata(x)\n    )\n    m &lt;- lm(formula = z ~ t, data = dtemp)\n    p &lt;- predict(\n      object = m,\n      newdata = data.frame(t = last(dtemp$t) + 1:6)\n    )\n    xts(\n      x = p,\n      order.by = index(last(x)) + (1:6) * deltat(x)\n    )\n  }\n)\n\n## Dodawanie modelu identycznościowego\ny$modelsAppend(\n  identity_prediction = function(x) {\n    x\n  }\n)\n\n### Listing operacji i modeli\ny$opsList()\n\n  id         name\n1  1 differencing\n2  2     logs_abs\n3  3      na_omit\n\ny$modelsList()\n\n  id                name\n1  1   linear_prediciton\n2  2 identity_prediction\n\n### Dodawanie ścieżki z modelem liniowym\ny$pathsAppend(\n  pathName = \"linear with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"linear_prediciton\"\n)\n\n### Dodawanie ścieżki z modelem identycznościowym / pozwala na\n### zobaczenia co dokładnie wchodzi do modelu predykcji\ny$pathsAppend(\n  pathName = \"identity with differencing\",\n  operations = c(\"differencing\", \"na_omit\"),\n  model = \"identity_prediction\"\n)\n\n### Listowanie zdefiniowanych ścieżek\n\ny$pathsList()\n\n  id                       name             operations               model\n1  1   linear with differencing differencing → na_omit   linear_prediciton\n2  2 identity with differencing differencing → na_omit identity_prediction\n\n### Obliczanie zdefiniowanych ścieżek\nz &lt;- y$pathsRun(pathName = \"identity with differencing\")\nzF &lt;- y$pathsRun(pathName = \"linear with differencing\")\n\n### Tworzenie wykresu na podstawie wyników\nggplot(\n  data = tibble(time = index(z), value = coredata(z)),\n  mapping = aes(x = time, y = value)\n) +\n  geom_line() +\n  geom_point() +\n  geom_line(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  geom_point(data = tibble(time = index(zF), value = coredata(zF)), color = \"red\") +\n  coord_cartesian(ylim = c(-5, 5)) +\n  labs(title = \"Time series and forecast\") +\n  theme_light()"
  },
  {
    "objectID": "Projekty/GA/index.html",
    "href": "Projekty/GA/index.html",
    "title": "Algorytm genetyczny",
    "section": "",
    "text": "Projekt wykonany w Pythonie na zajęcia Credit Scoring.\nPodstawowym zagadnieniem było zbudowanie modelu do oceny ryzyka potencjalnych klientów kredytowych za pomocą kodów udostępnionych przez wykłądowcę, pana dr Karola Przanowskiego. Dla chętnych była możliowość ich udoskonalenia wg własnej inwencji twórczej. Ja zdecydowałem się zaimplementować algorytm genetyczny do wyboru zmiennyc modelu.\nW danych mieliśmy ok. 200 zmiennych, a do modelu szukaliśmy najlepszej kombinacji kilku/kilkunastu. Głównym celem było znalezienie modelu z jak największym indeksem Gini, mierzącym jego siłę predykcyjną."
  },
  {
    "objectID": "Projekty/MLR/index.html",
    "href": "Projekty/MLR/index.html",
    "title": "Function Factory",
    "section": "",
    "text": "Projekt wykonany w ramach zajęć Zaawansowane programowanie w języku R.\n\n\nOpis projektu\nZadanie polega na napisaniu funkcji createFitter(), która przyjmuje tylko jeden argument size. Zadaniem funkcji jest stworzenie nowej funkcji, tzw. fittera, która zawiera prostą sięć neuronową MLP o jednej warstwie ukrytej o wielkości size. Funkcja ta powinna przyjmować dwa argumenty: data, który jest ramką danych (alternatywnie obiektem dziedziczącym z data.frame, np. tbl_df) oraz formula, który jest formuła opisującą co w podanej ramce danych jest targetem a co features. Przykładowo, jeżeli w ramace danych mamy zmienne (kolumny) x i y to formuła y ~ x oznacza, że sieć na podstawie zmiennej x prognozuje zmienną y. Oczywiście powinny być wspierane skróty, np. y ~ . oznacza, że zmienna y jest prognozowana na podstawie wszystkich pozostałych w ramce danych zmiennych. Zadaniem fittera jest zdefiniowane nowej kolejnej funkcji, która jest predyktorem a więc funkcją, która dla podanych zmiennych zwraca predykcje. Tak więc fitter na podstawie podanej próby trenuje sieć neuronową i zwraca funkcję, predyktor, która zawiera wytrenowaną sieć neuronową i jej zadaniem jest tworzenie predykcji z wykorzystaniem wytrenowanej sieci neuronowej.\n\n\nMoje rozwiązanie\n\nlibrary(dplyr)\n\ncreateFitter &lt;- function(size) {\n  #jesli nie mam pakietu, to go instaluje, jesli mam to włączam\n  if(!require(nnet)){\n    install.packages(\"nnet\")\n    library(nnet)\n  } else {\n    library(nnet)\n  }\n  \n  return(function(data, formula){ \n    # fitter\n    nn &lt;- nnet(formula, data, size = c(size), maxit=1000, rang = 0.1, decay = 5e-4, linout=T)\n    ## definicja f. lines dla klasy data.frame\n    e &lt;- parent.env(environment())\n    e$lines &lt;- function(x, ...) {\n      graphics::lines(x = x[,1], y = x[,2], ...)\n    }\n    \n    return(function(newData){\n      #predyktor\n      #Zwraca df ktory ma dwie kolumny, x z zbioru dTest i y wyliczone na podstawie sieci i nowych x\n      out &lt;- data.frame(newData[,1], predict(nn, newData))\n      return(out)\n    })\n  })\n}\n\n\n\nPrzykłady\n\nPrzykład 1\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzenie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 10)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 1\n\n\n\n\n\n\nPrzykład 2\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd &lt;- tibble(\n  x = rnorm(10^3),\n  y = x^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter &lt;- createFitter(size = 3)\n\n### Tworzenie predyktora. \npredictor &lt;- fitter(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\n\nlines(x = predictor(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\n\n\n\n\nPrzykład 2\n\n\n\n\n\n\nPrzyklad 3\n\n### Tworzenie przykładowych danych - zbiór treningowy\nd1 &lt;- tibble(\n  x = rnorm(10^3, mean = -5),\n  y = (x + 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd2 &lt;- tibble(\n  x = rnorm(10^3, mean = 5),\n  y = (x - 5)^2 + 3 * cos(x) + rnorm(10^3, sd = 0.4)\n)\nd &lt;- rbind(d1, d2)\n\n### Tworzenie zbioru testowego\ndTest &lt;- tibble(\n  x = seq(\n    from = min(d$x),\n    to = max(d$x),\n    length.out = 100)) ## features\n\n\n### Tworzesnie fittera. Poniżej wykorzystujemy jedynie 10 neuronów w\n### warstwie ukrytej.\nfitter3 &lt;- createFitter(size = 3)\nfitter20 &lt;- createFitter(size = 20)\n\n### Tworzenie predyktora. \npredictor3 &lt;- fitter3(formula = y ~ x, data = d)\npredictor20 &lt;- fitter20(formula = y ~ x, data = d)\n\n\n### Wizualizacja przykładowych danych wyniku\n#| label: przyklad-3\n#| fig-cap: \"Przykład 3\"\n#| warning: false\nplot(d, pch = 20,\n     col = rgb(1, 0, .5, 0.2),\n     xlab = \"feature\", ylab = \"target\")\ngrid(lty = \"solid\", col = \"lightgray\")\nlines(x = predictor3(newData = dTest),\n      col = rgb(.5, 0, 1, .9),\n      lwd = 2)\nlines(x = predictor20(newData = dTest),\n      col = rgb(0, .5, 1, .9),\n      lwd = 2)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Igor Domaradzki",
    "section": "",
    "text": "Cześć! Witam na mojej stronie, na której znajdziecie moje portforlio Data Science.\nJestem studentem SGH na kierunku magisterskim Analiza danych - big data.\nWcześniej ukończyłem tam licencjat na kierunku Metody ilościowe w ekonomii i systemy informacyjne, gdzie napisałem pracę licencjacką “Zastosowanie teorii gier do analizy wybranych zagadnień w sporcie”\nMoje CV\nPoniżej kilka projektów, które stworzyłem.\n\n\n\nTo ja!\n\n\nStrona stworzona z użyciem RPosit Quarto i opublikowana dzięki Github Pages.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorytm genetyczny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFunction Factory\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR Wrapped\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR6Class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]